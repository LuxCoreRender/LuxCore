#include "pathgpu2/kernels/kernels.h"
std::string luxrays::KernelSource_PathGPU2_kernels = 
"/***************************************************************************\n"
" *   Copyright (C) 1998-2010 by authors (see AUTHORS.txt )                 *\n"
" *                                                                         *\n"
" *   This file is part of LuxRays.                                         *\n"
" *                                                                         *\n"
" *   LuxRays is free software; you can redistribute it and/or modify       *\n"
" *   it under the terms of the GNU General Public License as published by  *\n"
" *   the Free Software Foundation; either version 3 of the License, or     *\n"
" *   (at your option) any later version.                                   *\n"
" *                                                                         *\n"
" *   LuxRays is distributed in the hope that it will be useful,            *\n"
" *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n"
" *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n"
" *   GNU General Public License for more details.                          *\n"
" *                                                                         *\n"
" *   You should have received a copy of the GNU General Public License     *\n"
" *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *\n"
" *                                                                         *\n"
" *   LuxRays website: http://www.luxrender.net                             *\n"
" ***************************************************************************/\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Init Kernel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"__kernel void Init(\n"
"		__global GPUTask *tasks,\n"
"		__global GPUTaskStats *taskStats,\n"
"		__global Ray *rays\n"
"#if defined(PARAM_CAMERA_DYNAMIC)\n"
"		, __global float *cameraData\n"
"#endif\n"
"#if (PARAM_SAMPLER_TYPE == 3)\n"
"		, __local float *localMemTempBuff\n"
"#endif\n"
"		) {\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= PARAM_TASK_COUNT)\n"
"		return;\n"
"\n"
"	//if (gid == 0)\n"
"	//	printf(\"GPUTask: %d\\n\", sizeof(GPUTask));\n"
"\n"
"	// Initialize the task\n"
"	__global GPUTask *task = &tasks[gid];\n"
"\n"
"	// Initialize random number generator\n"
"	Seed seed;\n"
"	InitRandomGenerator(PARAM_SEED + gid, &seed);\n"
"\n"
"	// Initialize the sample\n"
"	Sampler_Init(gid,\n"
"#if (PARAM_SAMPLER_TYPE == 3)\n"
"			localMemTempBuff,\n"
"#endif\n"
"			&seed, &task->sample);\n"
"\n"
"	// Initialize the path\n"
"	GenerateCameraPath(task, &rays[gid], &seed\n"
"#if defined(PARAM_CAMERA_DYNAMIC)\n"
"			, cameraData\n"
"#endif\n"
"			);\n"
"\n"
"	// Save the seed\n"
"	task->seed.s1 = seed.s1;\n"
"	task->seed.s2 = seed.s2;\n"
"	task->seed.s3 = seed.s3;\n"
"\n"
"	__global GPUTaskStats *taskStat = &taskStats[gid];\n"
"	taskStat->sampleCount = 0;\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// InitFrameBuffer Kernel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"__kernel void InitFrameBuffer(\n"
"		__global Pixel *frameBuffer\n"
"		) {\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= PARAM_IMAGE_WIDTH * PARAM_IMAGE_HEIGHT)\n"
"		return;\n"
"\n"
"#if (PARAM_IMAGE_FILTER_TYPE == 0)\n"
"\n"
"	__global Pixel *p = &frameBuffer[gid];\n"
"	p->c.r = 0.f;\n"
"	p->c.g = 0.f;\n"
"	p->c.b = 0.f;\n"
"	p->count = 0.f;\n"
"\n"
"#elif (PARAM_IMAGE_FILTER_TYPE == 1) || (PARAM_IMAGE_FILTER_TYPE == 2) || (PARAM_IMAGE_FILTER_TYPE == 3) || (PARAM_IMAGE_FILTER_TYPE == 4)\n"
"\n"
"	__global Pixel *p = &frameBuffer[gid * 9];\n"
"	for (int i = 0; i < 9; ++i) {\n"
"		p->c.r = 0.f;\n"
"		p->c.g = 0.f;\n"
"		p->c.b = 0.f;\n"
"		p->count = 0.f;\n"
"		++p;\n"
"	}\n"
"\n"
"#else\n"
"\n"
"Error: unknown image filter !!!\n"
"\n"
"#endif\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// AdvancePaths Kernel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"__kernel void AdvancePaths(\n"
"		__global GPUTask *tasks,\n"
"		__global Ray *rays,\n"
"		__global RayHit *rayHits,\n"
"		__global Pixel *frameBuffer,\n"
"		__global Material *mats,\n"
"		__global uint *meshMats,\n"
"		__global uint *meshIDs,\n"
"		__global Spectrum *vertColors,\n"
"		__global Vector *vertNormals,\n"
"		__global Triangle *triangles\n"
"#if defined(PARAM_CAMERA_DYNAMIC)\n"
"		, __global float *cameraData\n"
"#endif\n"
"#if defined(PARAM_HAVE_INFINITELIGHT)\n"
"		, __global Spectrum *infiniteLightMap\n"
"#endif\n"
"#if defined(PARAM_DIRECT_LIGHT_SAMPLING)\n"
"		, __global TriangleLight *triLights\n"
"#endif\n"
"#if defined(PARAM_HAS_TEXTUREMAPS)\n"
"        , __global Spectrum *texMapRGBBuff\n"
"#if defined(PARAM_HAS_ALPHA_TEXTUREMAPS)\n"
"		, __global float *texMapAlphaBuff\n"
"#endif\n"
"        , __global TexMap *texMapDescBuff\n"
"        , __global unsigned int *meshTexsBuff\n"
"        , __global UV *vertUVs\n"
"#endif\n"
"		) {\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= PARAM_TASK_COUNT)\n"
"		return;\n"
"\n"
"	__global GPUTask *task = &tasks[gid];\n"
"	uint pathState = task->pathState.state;\n"
"\n"
"#if (PARAM_SAMPLER_TYPE == 0)\n"
"	// Read the seed\n"
"	Seed seed;\n"
"	seed.s1 = task->seed.s1;\n"
"	seed.s2 = task->seed.s2;\n"
"	seed.s3 = task->seed.s3;\n"
"#endif\n"
"\n"
"	__global Sample *sample = &task->sample;\n"
"\n"
"	__global Ray *ray = &rays[gid];\n"
"	__global RayHit *rayHit = &rayHits[gid];\n"
"	const uint currentTriangleIndex = rayHit->index;\n"
"\n"
"	const float hitPointT = rayHit->t;\n"
"    const float hitPointB1 = rayHit->b1;\n"
"    const float hitPointB2 = rayHit->b2;\n"
"\n"
"    Vector rayDir = ray->d;\n"
"\n"
"	Point hitPoint;\n"
"    hitPoint.x = ray->o.x + rayDir.x * hitPointT;\n"
"    hitPoint.y = ray->o.y + rayDir.y * hitPointT;\n"
"    hitPoint.z = ray->o.z + rayDir.z * hitPointT;\n"
"\n"
"	Spectrum throughput = task->pathState.throughput;\n"
"\n"
"	switch (pathState) {\n"
"		case PATH_STATE_NEXT_VERTEX: {\n"
"			if (currentTriangleIndex != 0xffffffffu) {\n"
"				// Something was hit\n"
"\n"
"				const uint pathDepth = task->pathState.depth + 1;\n"
"#if (PARAM_SAMPLER_TYPE == 1) || (PARAM_SAMPLER_TYPE == 3)\n"
"				__global float *sampleData = &sample->u[IDX_BSDF_OFFSET + SAMPLE_SIZE * pathDepth];\n"
"#elif (PARAM_SAMPLER_TYPE == 2)\n"
"				__global float *sampleData = &sample->u[sample->proposed][IDX_BSDF_OFFSET + SAMPLE_SIZE * pathDepth];\n"
"#endif\n"
"\n"
"				const uint meshIndex = meshIDs[currentTriangleIndex];\n"
"				__global Material *hitPointMat = &mats[meshMats[meshIndex]];\n"
"				uint matType = hitPointMat->type;\n"
"\n"
"				// Interpolate Color\n"
"				Spectrum shadeColor;\n"
"				Mesh_InterpolateColor(vertColors, triangles, currentTriangleIndex, hitPointB1, hitPointB2, &shadeColor);\n"
"\n"
"#if defined(PARAM_HAS_TEXTUREMAPS)\n"
"				// Interpolate UV coordinates\n"
"				UV uv;\n"
"				Mesh_InterpolateUV(vertUVs, triangles, currentTriangleIndex, hitPointB1, hitPointB2, &uv);\n"
"\n"
"				// Check it the mesh has a texture map\n"
"				unsigned int texIndex = meshTexsBuff[meshIndex];\n"
"				if (texIndex != 0xffffffffu) {\n"
"					__global TexMap *texMap = &texMapDescBuff[texIndex];\n"
"\n"
"#if defined(PARAM_HAS_ALPHA_TEXTUREMAPS)\n"
"					// Check if it has an alpha channel\n"
"					if (texMap->alphaOffset != 0xffffffffu) {\n"
"						const float alpha = TexMap_GetAlpha(&texMapAlphaBuff[texMap->alphaOffset], texMap->width, texMap->height, uv.u, uv.v);\n"
"\n"
"#if (PARAM_SAMPLER_TYPE == 0)\n"
"						const float texAlphaSample = RndFloatValue(&seed);\n"
"#elif (PARAM_SAMPLER_TYPE == 1) || (PARAM_SAMPLER_TYPE == 2) || (PARAM_SAMPLER_TYPE == 3)\n"
"						const float texAlphaSample = sampleData[IDX_TEX_ALPHA];\n"
"#endif\n"
"\n"
"						if ((alpha == 0.0f) || ((alpha < 1.f) && (texAlphaSample > alpha))) {\n"
"							// Continue to trace the ray\n"
"							matType = MAT_NULL;\n"
"						}\n"
"					}\n"
"#endif\n"
"\n"
"					Spectrum texColor;\n"
"					TexMap_GetColor(&texMapRGBBuff[texMap->rgbOffset], texMap->width, texMap->height, uv.u, uv.v, &texColor);\n"
"\n"
"					shadeColor.r *= texColor.r;\n"
"					shadeColor.g *= texColor.g;\n"
"					shadeColor.b *= texColor.b;\n"
"				}\n"
"#endif\n"
"\n"
"				throughput.r *= shadeColor.r;\n"
"				throughput.g *= shadeColor.g;\n"
"				throughput.b *= shadeColor.b;\n"
"\n"
"				// Interpolate the normal\n"
"				Vector N;\n"
"				Mesh_InterpolateNormal(vertNormals, triangles, currentTriangleIndex, hitPointB1, hitPointB2, &N);\n"
"\n"
"				// Flip the normal if required\n"
"				Vector shadeN;\n"
"				const float nFlip = (Dot(&rayDir, &N) > 0.f) ? -1.f : 1.f;\n"
"				shadeN.x = nFlip * N.x;\n"
"				shadeN.y = nFlip * N.y;\n"
"				shadeN.z = nFlip * N.z;\n"
"\n"
"#if (PARAM_SAMPLER_TYPE == 0)\n"
"				const float u0 = RndFloatValue(&seed);\n"
"				const float u1 = RndFloatValue(&seed);\n"
"#elif (PARAM_SAMPLER_TYPE == 1) ||(PARAM_SAMPLER_TYPE == 2) || (PARAM_SAMPLER_TYPE == 3)\n"
"				const float u0 = sampleData[IDX_BSDF_X];\n"
"				const float u1 = sampleData[IDX_BSDF_Y];\n"
"#endif\n"
"\n"
"#if defined(PARAM_ENABLE_MAT_MATTEMIRROR) || defined(PARAM_ENABLE_MAT_MATTEMETAL) || defined(PARAM_ENABLE_MAT_ALLOY)\n"
"#if (PARAM_SAMPLER_TYPE == 0)\n"
"				const float u2 = RndFloatValue(&seed);\n"
"#elif (PARAM_SAMPLER_TYPE == 1) ||(PARAM_SAMPLER_TYPE == 2) || (PARAM_SAMPLER_TYPE == 3)\n"
"				const float u2 = sampleData[IDX_BSDF_Z];\n"
"#endif\n"
"#endif\n"
"\n"
"				Vector wo;\n"
"				wo.x = -rayDir.x;\n"
"				wo.y = -rayDir.y;\n"
"				wo.z = -rayDir.z;\n"
"\n"
"				Vector wi;\n"
"				float pdf;\n"
"				Spectrum f;\n"
"\n"
"				switch (matType) {\n"
"\n"
"#if defined(PARAM_ENABLE_MAT_MATTE)\n"
"					case MAT_MATTE:\n"
"						Matte_Sample_f(&hitPointMat->param.matte, &wo, &wi, &pdf, &f, &shadeN, u0, u1\n"
"#if defined(PARAM_DIRECT_LIGHT_SAMPLING)\n"
"								, &task->pathState.specularBounce\n"
"#endif\n"
"								);\n"
"						break;\n"
"#endif\n"
"\n"
"#if defined(PARAM_ENABLE_MAT_AREALIGHT)\n"
"					case MAT_AREALIGHT: {\n"
"#if defined(PARAM_DIRECT_LIGHT_SAMPLING)\n"
"						if (task->pathState.specularBounce) {\n"
"#endif\n"
"							Spectrum Le;\n"
"							AreaLight_Le(&hitPointMat->param.areaLight, &wo, &N, &Le);\n"
"							sample->radiance.r += throughput.r * Le.r;\n"
"							sample->radiance.g += throughput.g * Le.g;\n"
"							sample->radiance.b += throughput.b * Le.b;\n"
"\n"
"#if defined(PARAM_DIRECT_LIGHT_SAMPLING)\n"
"						}\n"
"#endif\n"
"\n"
"						pdf = 0.f;\n"
"						break;\n"
"					}\n"
"#endif\n"
"\n"
"#if defined(PARAM_ENABLE_MAT_MIRROR)\n"
"					case MAT_MIRROR:\n"
"						Mirror_Sample_f(&hitPointMat->param.mirror, &wo, &wi, &pdf, &f, &shadeN\n"
"#if defined(PARAM_DIRECT_LIGHT_SAMPLING)\n"
"								, &task->pathState.specularBounce\n"
"#endif\n"
"								);\n"
"						break;\n"
"#endif\n"
"\n"
"#if defined(PARAM_ENABLE_MAT_GLASS)\n"
"					case MAT_GLASS:\n"
"						Glass_Sample_f(&hitPointMat->param.glass, &wo, &wi, &pdf, &f, &N, &shadeN, u0\n"
"#if defined(PARAM_DIRECT_LIGHT_SAMPLING)\n"
"								, &task->pathState.specularBounce\n"
"#endif\n"
"								);\n"
"						break;\n"
"#endif\n"
"\n"
"#if defined(PARAM_ENABLE_MAT_MATTEMIRROR)\n"
"					case MAT_MATTEMIRROR:\n"
"						MatteMirror_Sample_f(&hitPointMat->param.matteMirror, &wo, &wi, &pdf, &f, &shadeN, u0, u1, u2\n"
"#if defined(PARAM_DIRECT_LIGHT_SAMPLING)\n"
"								, &task->pathState.specularBounce\n"
"#endif\n"
"								);\n"
"						break;\n"
"#endif\n"
"\n"
"#if defined(PARAM_ENABLE_MAT_METAL)\n"
"					case MAT_METAL:\n"
"						Metal_Sample_f(&hitPointMat->param.metal, &wo, &wi, &pdf, &f, &shadeN, u0, u1\n"
"#if defined(PARAM_DIRECT_LIGHT_SAMPLING)\n"
"								, &task->pathState.specularBounce\n"
"#endif\n"
"								);\n"
"						break;\n"
"#endif\n"
"\n"
"#if defined(PARAM_ENABLE_MAT_MATTEMETAL)\n"
"					case MAT_MATTEMETAL:\n"
"						MatteMetal_Sample_f(&hitPointMat->param.matteMetal, &wo, &wi, &pdf, &f, &shadeN, u0, u1, u2\n"
"#if defined(PARAM_DIRECT_LIGHT_SAMPLING)\n"
"								, &task->pathState.specularBounce\n"
"#endif\n"
"								);\n"
"						break;\n"
"#endif\n"
"\n"
"#if defined(PARAM_ENABLE_MAT_ALLOY)\n"
"					case MAT_ALLOY:\n"
"						Alloy_Sample_f(&hitPointMat->param.alloy, &wo, &wi, &pdf, &f, &shadeN, u0, u1, u2\n"
"#if defined(PARAM_DIRECT_LIGHT_SAMPLING)\n"
"								, &task->pathState.specularBounce\n"
"#endif\n"
"								);\n"
"						break;\n"
"#endif\n"
"\n"
"#if defined(PARAM_ENABLE_MAT_ARCHGLASS)\n"
"					case MAT_ARCHGLASS:\n"
"						ArchGlass_Sample_f(&hitPointMat->param.archGlass, &wo, &wi, &pdf, &f, &N, &shadeN, u0\n"
"#if defined(PARAM_DIRECT_LIGHT_SAMPLING)\n"
"								, &task->pathState.specularBounce\n"
"#endif\n"
"								);\n"
"						break;\n"
"#endif\n"
"\n"
"					case MAT_NULL:\n"
"						wi = rayDir;\n"
"						pdf = 1.f;\n"
"						f.r = 1.f;\n"
"						f.g = 1.f;\n"
"						f.b = 1.f;\n"
"\n"
"						// I have also to restore the original throughput\n"
"						throughput = task->pathState.throughput;\n"
"						break;\n"
"\n"
"					default:\n"
"						// Huston, we have a problem...\n"
"						pdf = 0.f;\n"
"						break;\n"
"				}\n"
"\n"
"				const float invPdf = ((pdf <= 0.f) || (pathDepth >= PARAM_MAX_PATH_DEPTH)) ? 0.f : (1.f / pdf);\n"
"\n"
"				//if (pathDepth > 2)\n"
"				//	printf(\"Depth: %d Throughput: (%f, %f, %f) f: (%f, %f, %f) Pdf: %f\\n\", pathDepth, throughput.r, throughput.g, throughput.b, f.r, f.g, f.b, pdf);\n"
"\n"
"				throughput.r *= f.r * invPdf;\n"
"				throughput.g *= f.g * invPdf;\n"
"				throughput.b *= f.b * invPdf;\n"
"\n"
"				// Russian roulette\n"
"\n"
"#if (PARAM_SAMPLER_TYPE == 0)\n"
"				const float rrSample = RndFloatValue(&seed);\n"
"#elif (PARAM_SAMPLER_TYPE == 1) || (PARAM_SAMPLER_TYPE == 2) || (PARAM_SAMPLER_TYPE == 3)\n"
"				const float rrSample = sampleData[IDX_RR];\n"
"#endif\n"
"\n"
"				const float rrProb = max(max(throughput.r, max(throughput.g, throughput.b)), (float) PARAM_RR_CAP);\n"
"				const float invRRProb = (pathDepth > PARAM_RR_DEPTH) ? ((rrProb >= rrSample) ? 0.f : (1.f / rrProb)) : 1.f;\n"
"				throughput.r *= invRRProb;\n"
"				throughput.g *= invRRProb;\n"
"				throughput.b *= invRRProb;\n"
"\n"
"				//if (pathDepth > 2)\n"
"				//	printf(\"Depth: %d Throughput: (%f, %f, %f)\\n\", pathDepth, throughput.r, throughput.g, throughput.b);\n"
"\n"
"#if defined(PARAM_DIRECT_LIGHT_SAMPLING)\n"
"				float directLightPdf;\n"
"				switch (matType) {\n"
"					case MAT_MATTE:\n"
"						directLightPdf = 1.f;\n"
"						break;\n"
"					case MAT_MATTEMIRROR:\n"
"						directLightPdf = 1.f / hitPointMat->param.matteMirror.mattePdf;\n"
"						break;\n"
"					case MAT_MATTEMETAL:\n"
"						directLightPdf = 1.f / hitPointMat->param.matteMetal.mattePdf;\n"
"						break;\n"
"					case MAT_ALLOY: {\n"
"						// Schilick's approximation\n"
"						const float c = 1.f + Dot(&rayDir, &shadeN);\n"
"						const float R0 = hitPointMat->param.alloy.R0;\n"
"						const float Re = R0 + (1.f - R0) * c * c * c * c * c;\n"
"\n"
"						const float P = .25f + .5f * Re;\n"
"\n"
"						directLightPdf = (1.f - P) / (1.f - Re);\n"
"						break;\n"
"					}\n"
"					default:\n"
"						directLightPdf = 0.f;\n"
"						break;\n"
"				}\n"
"\n"
"				if (directLightPdf > 0.f) {\n"
"#if (PARAM_SAMPLER_TYPE == 0)\n"
"					const float ul0 = RndFloatValue(&seed);\n"
"					const float ul1 = RndFloatValue(&seed);\n"
"					const float ul2 = RndFloatValue(&seed);\n"
"#elif (PARAM_SAMPLER_TYPE == 1) || (PARAM_SAMPLER_TYPE == 2) || (PARAM_SAMPLER_TYPE == 3)\n"
"					const float ul0 = sampleData[IDX_DIRECTLIGHT_X];\n"
"					const float ul1 = sampleData[IDX_DIRECTLIGHT_Y];\n"
"					const float ul2 = sampleData[IDX_DIRECTLIGHT_Z];\n"
"#endif\n"
"\n"
"					// Select a light source to sample\n"
"					const uint lightIndex = min((uint)floor(PARAM_DL_LIGHT_COUNT * ul0), (uint)(PARAM_DL_LIGHT_COUNT - 1));\n"
"					__global TriangleLight *l = &triLights[lightIndex];\n"
"\n"
"					// Setup the shadow ray\n"
"					Spectrum Le;\n"
"					float lightPdf;\n"
"					Ray shadowRay;\n"
"					TriangleLight_Sample_L(l, &hitPoint, &lightPdf, &Le, &shadowRay, ul1, ul2);\n"
"\n"
"					const float dp = Dot(&shadeN, &shadowRay.d);\n"
"					const float matPdf = (dp <= 0.f) ? 0.f : 1.f;\n"
"\n"
"					const float pdf = lightPdf * matPdf * directLightPdf;\n"
"					if (pdf > 0.f) {\n"
"						Spectrum throughputLightDir = task->pathState.throughput;\n"
"						throughputLightDir.r *= shadeColor.r;\n"
"						throughputLightDir.g *= shadeColor.g;\n"
"						throughputLightDir.b *= shadeColor.b;\n"
"\n"
"						const float k = dp * PARAM_DL_LIGHT_COUNT / (pdf * M_PI);\n"
"						// NOTE: I assume all matte mixed material have a MatteParam as first field\n"
"						task->pathState.lightRadiance.r = throughputLightDir.r * hitPointMat->param.matte.r * k * Le.r;\n"
"						task->pathState.lightRadiance.g = throughputLightDir.g * hitPointMat->param.matte.g * k * Le.g;\n"
"						task->pathState.lightRadiance.b = throughputLightDir.b * hitPointMat->param.matte.b * k * Le.b;\n"
"\n"
"						*ray = shadowRay;\n"
"\n"
"						// Save data for next path vertex\n"
"						task->pathState.nextPathRay.o = hitPoint;\n"
"						task->pathState.nextPathRay.d = wi;\n"
"						task->pathState.nextPathRay.mint = PARAM_RAY_EPSILON;\n"
"						task->pathState.nextPathRay.maxt = FLT_MAX;\n"
"\n"
"						task->pathState.nextThroughput = throughput;\n"
"\n"
"						pathState = PATH_STATE_SAMPLE_LIGHT;\n"
"					} else {\n"
"						// Skip the shadow ray tracing step\n"
"\n"
"						if ((throughput.r <= 0.f) && (throughput.g <= 0.f) && (throughput.b <= 0.f))\n"
"							pathState = PATH_STATE_DONE;\n"
"						else {\n"
"							ray->o = hitPoint;\n"
"							ray->d = wi;\n"
"							ray->mint = PARAM_RAY_EPSILON;\n"
"							ray->maxt = FLT_MAX;\n"
"\n"
"							task->pathState.throughput = throughput;\n"
"							task->pathState.depth = pathDepth;\n"
"\n"
"							pathState = PATH_STATE_NEXT_VERTEX;\n"
"						}\n"
"					}\n"
"				} else {\n"
"					// Skip the shadow ray tracing step\n"
"\n"
"					if ((throughput.r <= 0.f) && (throughput.g <= 0.f) && (throughput.b <= 0.f))\n"
"						pathState = PATH_STATE_DONE;\n"
"					else {\n"
"						ray->o = hitPoint;\n"
"						ray->d = wi;\n"
"						ray->mint = PARAM_RAY_EPSILON;\n"
"						ray->maxt = FLT_MAX;\n"
"\n"
"						task->pathState.throughput = throughput;\n"
"						task->pathState.depth = pathDepth;\n"
"\n"
"						pathState = PATH_STATE_NEXT_VERTEX;\n"
"					}\n"
"				}\n"
"\n"
"#else\n"
"\n"
"				if ((throughput.r <= 0.f) && (throughput.g <= 0.f) && (throughput.b <= 0.f))\n"
"					pathState = PATH_STATE_DONE;\n"
"				else {\n"
"					// Setup next ray\n"
"					ray->o = hitPoint;\n"
"					ray->d = wi;\n"
"					ray->mint = PARAM_RAY_EPSILON;\n"
"					ray->maxt = FLT_MAX;\n"
"\n"
"					task->pathState.throughput = throughput;\n"
"					task->pathState.depth = pathDepth;\n"
"\n"
"					pathState = PATH_STATE_NEXT_VERTEX;\n"
"				}\n"
"#endif\n"
"\n"
"			} else {\n"
"#if defined(PARAM_HAVE_INFINITELIGHT)\n"
"				Spectrum Le;\n"
"				InfiniteLight_Le(infiniteLightMap, &Le, &rayDir);\n"
"\n"
"				/*if (task->pathState.depth > 0)\n"
"					printf(\"Throughput: (%f, %f, %f) Le: (%f, %f, %f)\\n\", throughput.r, throughput.g, throughput.b, Le.r, Le.g, Le.b);*/\n"
"\n"
"				sample->radiance.r += throughput.r * Le.r;\n"
"				sample->radiance.g += throughput.g * Le.g;\n"
"				sample->radiance.b += throughput.b * Le.b;\n"
"#endif\n"
"\n"
"				pathState = PATH_STATE_DONE;\n"
"			}\n"
"			break;\n"
"		}\n"
"\n"
"#if defined(PARAM_DIRECT_LIGHT_SAMPLING)\n"
"		case PATH_STATE_SAMPLE_LIGHT: {\n"
"			if (currentTriangleIndex != 0xffffffffu) {\n"
"				// The shadow ray has hit something\n"
"\n"
"#if defined(PARAM_HAS_TEXTUREMAPS) && defined(PARAM_HAS_ALPHA_TEXTUREMAPS)\n"
"				// Check if I have to continue to trace the shadow ray\n"
"\n"
"				const uint pathDepth = task->pathState.depth;\n"
"#if (PARAM_SAMPLER_TYPE == 1) || (PARAM_SAMPLER_TYPE == 3)\n"
"				__global float *sampleData = &sample->u[IDX_BSDF_OFFSET + SAMPLE_SIZE * pathDepth];\n"
"#elif (PARAM_SAMPLER_TYPE == 2)\n"
"				__global float *sampleData = &sample->u[sample->proposed][IDX_BSDF_OFFSET + SAMPLE_SIZE * pathDepth];\n"
"#endif\n"
"\n"
"				const uint meshIndex = meshIDs[currentTriangleIndex];\n"
"				__global Material *hitPointMat = &mats[meshMats[meshIndex]];\n"
"				uint matType = hitPointMat->type;\n"
"\n"
"				// Interpolate UV coordinates\n"
"				UV uv;\n"
"				Mesh_InterpolateUV(vertUVs, triangles, currentTriangleIndex, hitPointB1, hitPointB2, &uv);\n"
"\n"
"				// Check it the mesh has a texture map\n"
"				unsigned int texIndex = meshTexsBuff[meshIndex];\n"
"				if (texIndex != 0xffffffffu) {\n"
"					__global TexMap *texMap = &texMapDescBuff[texIndex];\n"
"\n"
"					// Check if it has an alpha channel\n"
"					if (texMap->alphaOffset != 0xffffffffu) {\n"
"						const float alpha = TexMap_GetAlpha(&texMapAlphaBuff[texMap->alphaOffset], texMap->width, texMap->height, uv.u, uv.v);\n"
"\n"
"#if (PARAM_SAMPLER_TYPE == 0)\n"
"						const float texAlphaSample = RndFloatValue(&seed);\n"
"#elif (PARAM_SAMPLER_TYPE == 1) || (PARAM_SAMPLER_TYPE == 2) || (PARAM_SAMPLER_TYPE == 3)\n"
"						const float texAlphaSample = sampleData[IDX_TEX_ALPHA];\n"
"#endif\n"
"\n"
"						if ((alpha == 0.0f) || ((alpha < 1.f) && (texAlphaSample > alpha))) {\n"
"							// Continue to trace the ray\n"
"							matType = MAT_NULL;\n"
"						}\n"
"					}\n"
"				}\n"
"\n"
"				if (matType == MAT_ARCHGLASS) {\n"
"					task->pathState.lightRadiance.r *= hitPointMat->param.archGlass.refrct_r;\n"
"					task->pathState.lightRadiance.g *= hitPointMat->param.archGlass.refrct_g;\n"
"					task->pathState.lightRadiance.b *= hitPointMat->param.archGlass.refrct_b;\n"
"				}\n"
"\n"
"				if ((matType == MAT_ARCHGLASS) || (matType == MAT_NULL)) {\n"
"					const float hitPointT = rayHit->t;\n"
"\n"
"					Point hitPoint;\n"
"					hitPoint.x = ray->o.x + rayDir.x * hitPointT;\n"
"					hitPoint.y = ray->o.y + rayDir.y * hitPointT;\n"
"					hitPoint.z = ray->o.z + rayDir.z * hitPointT;\n"
"\n"
"					// Continue to trace the ray\n"
"					ray->o = hitPoint;\n"
"					ray->maxt -= hitPointT;\n"
"				} else\n"
"					pathState = PATH_STATE_NEXT_VERTEX;\n"
"\n"
"#else\n"
"				// The light is source is not visible\n"
"\n"
"				pathState = PATH_STATE_NEXT_VERTEX;\n"
"#endif\n"
"\n"
"			} else {\n"
"				// The light source is visible\n"
"\n"
"				sample->radiance.r += task->pathState.lightRadiance.r;\n"
"				sample->radiance.g += task->pathState.lightRadiance.g;\n"
"				sample->radiance.b += task->pathState.lightRadiance.b;\n"
"\n"
"				pathState = PATH_STATE_NEXT_VERTEX;\n"
"			}\n"
"\n"
"\n"
"			if (pathState == PATH_STATE_NEXT_VERTEX) {\n"
"				Spectrum throughput = task->pathState.nextThroughput;\n"
"				if ((throughput.r <= 0.f) && (throughput.g <= 0.f) && (throughput.b <= 0.f))\n"
"					pathState = PATH_STATE_DONE;\n"
"				else {\n"
"					// Restore the ray for the next path vertex\n"
"					*ray = task->pathState.nextPathRay;\n"
"\n"
"					task->pathState.throughput = throughput;\n"
"\n"
"					// Increase path depth\n"
"					task->pathState.depth += 1;\n"
"				}\n"
"			}\n"
"			break;\n"
"		}\n"
"#endif\n"
"	}\n"
"\n"
"	if (pathState == PATH_STATE_DONE) {\n"
"#if (PARAM_IMAGE_FILTER_TYPE == 0)\n"
"\n"
"#if (PARAM_SAMPLER_TYPE == 0) || (PARAM_SAMPLER_TYPE == 1) || (PARAM_SAMPLER_TYPE == 3)\n"
"		Spectrum radiance = sample->radiance;\n"
"		SplatSample(frameBuffer, sample->pixelIndex, &radiance, 1.f);\n"
"#elif (PARAM_SAMPLER_TYPE == 2)\n"
"\n"
"\n"
"#if (PARAM_SAMPLER_TYPE != 0)\n"
"		// Read the seed\n"
"		Seed seed;\n"
"		seed.s1 = task->seed.s1;\n"
"		seed.s2 = task->seed.s2;\n"
"		seed.s3 = task->seed.s3;\n"
"#endif\n"
"\n"
"		Sampler_MLT_SplatSample(frameBuffer, &seed, sample);\n"
"\n"
"#if (PARAM_SAMPLER_TYPE != 0)\n"
"		// Save the seed\n"
"		task->seed.s1 = seed.s1;\n"
"		task->seed.s2 = seed.s2;\n"
"		task->seed.s3 = seed.s3;\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"#else\n"
"\n"
"#if (PARAM_SAMPLER_TYPE == 0) || (PARAM_SAMPLER_TYPE == 1) || (PARAM_SAMPLER_TYPE == 3)\n"
"		__global float *sampleData = &sample->u[IDX_SCREEN_X];\n"
"		const float sx = sampleData[IDX_SCREEN_X] - .5f;\n"
"		const float sy = sampleData[IDX_SCREEN_X] - .5f;\n"
"\n"
"		Spectrum radiance = sample->radiance;\n"
"		SplatSample(frameBuffer, sample->pixelIndex, sx, sy, &radiance, 1.f);\n"
"#elif (PARAM_SAMPLER_TYPE == 2)\n"
"\n"
"#if (PARAM_SAMPLER_TYPE != 0)\n"
"		// Read the seed\n"
"		Seed seed;\n"
"		seed.s1 = task->seed.s1;\n"
"		seed.s2 = task->seed.s2;\n"
"		seed.s3 = task->seed.s3;\n"
"#endif\n"
"\n"
"		Sampler_MLT_SplatSample(frameBuffer, &seed, sample);\n"
"\n"
"#if (PARAM_SAMPLER_TYPE != 0)\n"
"		// Save the seed\n"
"		task->seed.s1 = seed.s1;\n"
"		task->seed.s2 = seed.s2;\n"
"		task->seed.s3 = seed.s3;\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"#endif\n"
"	}\n"
"\n"
"	task->pathState.state = pathState;\n"
"\n"
"#if (PARAM_SAMPLER_TYPE == 0)\n"
"	// Save the seed\n"
"	task->seed.s1 = seed.s1;\n"
"	task->seed.s2 = seed.s2;\n"
"	task->seed.s3 = seed.s3;\n"
"#endif\n"
"}\n"
;
