#include <string>
namespace luxrays { namespace ocl {
std::string KernelSource_mqbvh = 
"#line 2 \"mqbvh_kernel.cl\"\n"
"\n"
"/***************************************************************************\n"
" * Copyright 1998-2015 by authors (see AUTHORS.txt)                        *\n"
" *                                                                         *\n"
" *   This file is part of LuxRender.                                       *\n"
" *                                                                         *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");         *\n"
" * you may not use this file except in compliance with the License.        *\n"
" * You may obtain a copy of the License at                                 *\n"
" *                                                                         *\n"
" *     http://www.apache.org/licenses/LICENSE-2.0                          *\n"
" *                                                                         *\n"
" * Unless required by applicable law or agreed to in writing, software     *\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,       *\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*\n"
" * See the License for the specific language governing permissions and     *\n"
" * limitations under the License.                                          *\n"
" ***************************************************************************/\n"
"\n"
"// Using a large stack size to avoid the allocation of the array on\n"
"// GPU registers (otherwise the GPU can easily run out of registers)\n"
"#define STACK_SIZE 64\n"
"\n"
"void LeafIntersect(\n"
"		const Ray *ray,\n"
"		RayHit *rayHit,\n"
"		__global const QBVHNode* restrict nodes,\n"
"		__global const QuadTiangle* restrict quadTris) {\n"
"	// Prepare the ray for intersection\n"
"	QuadRay ray4;\n"
"    ray4.ox = (float4)ray->o.x;\n"
"    ray4.oy = (float4)ray->o.y;\n"
"    ray4.oz = (float4)ray->o.z;\n"
"\n"
"    ray4.dx = (float4)ray->d.x;\n"
"    ray4.dy = (float4)ray->d.y;\n"
"    ray4.dz = (float4)ray->d.z;\n"
"\n"
"    ray4.mint = (float4)ray->mint;\n"
"    ray4.maxt = (float4)ray->maxt;\n"
"\n"
"	const float4 invDir0 = (float4)(1.f / ray4.dx.s0);\n"
"	const float4 invDir1 = (float4)(1.f / ray4.dy.s0);\n"
"	const float4 invDir2 = (float4)(1.f / ray4.dz.s0);\n"
"\n"
"	const int signs0 = signbit(ray4.dx.s0);\n"
"	const int signs1 = signbit(ray4.dy.s0);\n"
"	const int signs2 = signbit(ray4.dz.s0);\n"
"\n"
"	rayHit->meshIndex = NULL_INDEX;\n"
"	rayHit->triangleIndex = NULL_INDEX;\n"
"\n"
"	//------------------------------\n"
"	// Main loop\n"
"	int todoNode = 0; // the index in the stack\n"
"	int nodeStack[STACK_SIZE];\n"
"	nodeStack[0] = 0; // first node to handle: root node\n"
"\n"
"	while (todoNode >= 0) {\n"
"		const int nodeData = nodeStack[todoNode];\n"
"		--todoNode;\n"
"\n"
"		// Leaves are identified by a negative index\n"
"		if (!QBVHNode_IsLeaf(nodeData)) {\n"
"			__global const QBVHNode* restrict node = &nodes[nodeData];\n"
"            const int4 visit = QBVHNode_BBoxIntersect(\n"
"                node->bboxes[signs0][0], node->bboxes[1 - signs0][0],\n"
"                node->bboxes[signs1][1], node->bboxes[1 - signs1][1],\n"
"                node->bboxes[signs2][2], node->bboxes[1 - signs2][2],\n"
"                &ray4,\n"
"				invDir0, invDir1, invDir2);\n"
"\n"
"			const int4 children = node->children;\n"
"\n"
"			// For some reason doing logic operations with int4 is very slow\n"
"			nodeStack[todoNode + 1] = children.s3;\n"
"			todoNode += (visit.s3 && !QBVHNode_IsEmpty(children.s3)) ? 1 : 0;\n"
"			nodeStack[todoNode + 1] = children.s2;\n"
"			todoNode += (visit.s2 && !QBVHNode_IsEmpty(children.s2)) ? 1 : 0;\n"
"			nodeStack[todoNode + 1] = children.s1;\n"
"			todoNode += (visit.s1 && !QBVHNode_IsEmpty(children.s1)) ? 1 : 0;\n"
"			nodeStack[todoNode + 1] = children.s0;\n"
"			todoNode += (visit.s0 && !QBVHNode_IsEmpty(children.s0)) ? 1 : 0;\n"
"		} else {\n"
"			// Perform intersection\n"
"			const uint nbQuadPrimitives = QBVHNode_NbQuadPrimitives(nodeData);\n"
"			const uint offset = QBVHNode_FirstQuadIndex(nodeData);\n"
"\n"
"			for (uint primNumber = offset; primNumber < (offset + nbQuadPrimitives); ++primNumber) {\n"
"                __global const QuadTiangle* restrict quadTri = &quadTris[primNumber];\n"
"                const float4 origx = quadTri->origx;\n"
"                const float4 origy = quadTri->origy;\n"
"                const float4 origz = quadTri->origz;\n"
"                const float4 edge1x = quadTri->edge1x;\n"
"                const float4 edge1y = quadTri->edge1y;\n"
"                const float4 edge1z = quadTri->edge1z;\n"
"                const float4 edge2x = quadTri->edge2x;\n"
"                const float4 edge2y = quadTri->edge2y;\n"
"                const float4 edge2z = quadTri->edge2z;\n"
"                const uint4 meshIndex = quadTri->meshIndex;\n"
"				const uint4 triangleIndex = quadTri->triangleIndex;\n"
"\n"
"				QuadTriangle_Intersect(\n"
"                    origx, origy, origz,\n"
"                    edge1x, edge1y, edge1z,\n"
"                    edge2x, edge2y, edge2z,\n"
"                    meshIndex, triangleIndex,\n"
"                    &ray4, rayHit);\n"
"            }\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"#define MQBVH_TRANSFORMATIONS_PARAM_DECL , __global const uint* restrict leafTransformationIndex , __global const Matrix4x4* restrict leafTransformations\n"
"#define MQBVH_TRANSFORMATIONS_PARAM , leafTransformationIndex, leafTransformations\n"
"\n"
"#define MQBVH_MOTIONSYSTEMS_PARAM_DECL , __global const MotionSystem* restrict leafMotionSystems , __global const InterpolatedTransform* restrict leafInterpolatedTransforms\n"
"#define MQBVH_MOTIONSYSTEMS_PARAM , leafMotionSystems, leafInterpolatedTransforms\n"
"\n"
"#define ACCELERATOR_INTERSECT_PARAM_DECL ,__global const QBVHNode* restrict nodes, __global const uint* restrict qbvhMemMap, __global const QBVHNode *leafNodes, __global const QuadTiangle* const leafQuadTris MQBVH_TRANSFORMATIONS_PARAM_DECL MQBVH_MOTIONSYSTEMS_PARAM_DECL\n"
"#define ACCELERATOR_INTERSECT_PARAM ,nodes, qbvhMemMap, leafNodes, leafQuadTris MQBVH_TRANSFORMATIONS_PARAM MQBVH_MOTIONSYSTEMS_PARAM\n"
"\n"
"void Accelerator_Intersect(\n"
"		const Ray *ray,\n"
"		RayHit *rayHit\n"
"		ACCELERATOR_INTERSECT_PARAM_DECL\n"
"		) {\n"
"	// Prepare the ray for intersection\n"
"    const float3 rayOrig = VLOAD3F_Private(&ray->o.x);\n"
"    const float3 rayDir = VLOAD3F_Private(&ray->d.x);\n"
"\n"
"	QuadRay ray4;\n"
"	ray4.ox = (float4)ray->o.x;\n"
"	ray4.oy = (float4)ray->o.y;\n"
"	ray4.oz = (float4)ray->o.z;\n"
"\n"
"	ray4.dx = (float4)ray->d.x;\n"
"	ray4.dy = (float4)ray->d.y;\n"
"	ray4.dz = (float4)ray->d.z;\n"
"\n"
"	ray4.mint = (float4)ray->mint;\n"
"	ray4.maxt = (float4)ray->maxt;\n"
"\n"
"	const float4 invDir0 = (float4)(1.f / ray4.dx.s0);\n"
"	const float4 invDir1 = (float4)(1.f / ray4.dy.s0);\n"
"	const float4 invDir2 = (float4)(1.f / ray4.dz.s0);\n"
"\n"
"	const int signs0 = signbit(ray4.dx.s0);\n"
"	const int signs1 = signbit(ray4.dy.s0);\n"
"	const int signs2 = signbit(ray4.dz.s0);\n"
"\n"
"	const float rayTime = ray->time;\n"
"\n"
"	rayHit->meshIndex = NULL_INDEX;\n"
"	rayHit->triangleIndex = NULL_INDEX;\n"
"\n"
"	//------------------------------\n"
"	// Main loop\n"
"	int todoNode = 0; // the index in the stack\n"
"	int nodeStack[STACK_SIZE];\n"
"	nodeStack[0] = 0; // first node to handle: root node\n"
"\n"
"	while (todoNode >= 0) {\n"
"		const int nodeData = nodeStack[todoNode];\n"
"		--todoNode;\n"
"\n"
"		// Leaves are identified by a negative index\n"
"		if (!QBVHNode_IsLeaf(nodeData)) {\n"
"			__global const QBVHNode* restrict node = &nodes[nodeData];\n"
"            const int4 visit = QBVHNode_BBoxIntersect(\n"
"                node->bboxes[signs0][0], node->bboxes[1 - signs0][0],\n"
"                node->bboxes[signs1][1], node->bboxes[1 - signs1][1],\n"
"                node->bboxes[signs2][2], node->bboxes[1 - signs2][2],\n"
"                &ray4,\n"
"				invDir0, invDir1, invDir2);\n"
"\n"
"			const int4 children = node->children;\n"
"\n"
"			// For some reason doing logic operations with int4 are very slow\n"
"			nodeStack[todoNode + 1] = children.s3;\n"
"			todoNode += (visit.s3 && !QBVHNode_IsEmpty(children.s3)) ? 1 : 0;\n"
"			nodeStack[todoNode + 1] = children.s2;\n"
"			todoNode += (visit.s2 && !QBVHNode_IsEmpty(children.s2)) ? 1 : 0;\n"
"			nodeStack[todoNode + 1] = children.s1;\n"
"			todoNode += (visit.s1 && !QBVHNode_IsEmpty(children.s1)) ? 1 : 0;\n"
"			nodeStack[todoNode + 1] = children.s0;\n"
"			todoNode += (visit.s0 && !QBVHNode_IsEmpty(children.s0)) ? 1 : 0;\n"
"		} else {\n"
"			// Perform intersection with QBVH leaf\n"
"			const uint leafIndex = QBVHNode_FirstQuadIndex(nodeData);\n"
"\n"
"            Ray tray;\n"
"			float3 newRayOrig = rayOrig;\n"
"			float3 newRayDir = rayDir;\n"
"\n"
"			if (leafTransformationIndex[leafIndex] != NULL_INDEX) {\n"
"				__global const Matrix4x4* restrict m = &leafTransformations[leafTransformationIndex[leafIndex]];\n"
"				newRayOrig = Matrix4x4_ApplyPoint(m, newRayOrig);\n"
"				newRayDir = Matrix4x4_ApplyVector(m, newRayDir);\n"
"			}\n"
"\n"
"			if (leafMotionSystems[leafIndex].interpolatedTransformFirstIndex != NULL_INDEX) {\n"
"				// Transform ray origin and direction\n"
"				Matrix4x4 m;\n"
"				MotionSystem_Sample(&leafMotionSystems[leafIndex], rayTime, leafInterpolatedTransforms, &m);\n"
"				newRayOrig = Matrix4x4_ApplyPoint_Private(&m, newRayOrig);\n"
"				newRayDir = Matrix4x4_ApplyVector_Private(&m, newRayDir);\n"
"			}\n"
"\n"
"			tray.o.x = newRayOrig.x;\n"
"			tray.o.y = newRayOrig.y;\n"
"			tray.o.z = newRayOrig.z;\n"
"			tray.d.x = newRayDir.x;\n"
"			tray.d.y = newRayDir.y;\n"
"			tray.d.z = newRayDir.z;\n"
"			tray.mint = ray4.mint.s0;\n"
"			tray.maxt = ray4.maxt.s0;\n"
"			tray.time = rayTime;\n"
"\n"
"            const uint memIndex = leafIndex * 2;\n"
"            const uint leafNodeOffset = qbvhMemMap[memIndex];\n"
"            __global const QBVHNode* restrict n = &leafNodes[leafNodeOffset];\n"
"            const uint leafQuadTriOffset = qbvhMemMap[memIndex + 1];\n"
"            __global const QuadTiangle* restrict qt = &leafQuadTris[leafQuadTriOffset];\n"
"\n"
"            RayHit tmpRayHit;\n"
"            LeafIntersect(&tray, &tmpRayHit, n, qt);\n"
"\n"
"            if (tmpRayHit.meshIndex != NULL_INDEX) {\n"
"                rayHit->t = tmpRayHit.t;\n"
"                rayHit->b1 = tmpRayHit.b1;\n"
"                rayHit->b2 = tmpRayHit.b2;\n"
"                rayHit->meshIndex = leafIndex;\n"
"				rayHit->triangleIndex = tmpRayHit.triangleIndex;\n"
"\n"
"                ray4.maxt = (float4)tmpRayHit.t;\n"
"            }\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void Accelerator_Intersect_RayBuffer(\n"
"		__global const Ray* restrict rays,\n"
"		__global RayHit *rayHits,\n"
"		const uint rayCount\n"
"		ACCELERATOR_INTERSECT_PARAM_DECL\n"
"		) {\n"
"	// Select the ray to check\n"
"	const int gid = get_global_id(0);\n"
"	if (gid >= rayCount)\n"
"		return;\n"
"\n"
"	Ray ray;\n"
"	Ray_ReadAligned4_Private(&rays[gid], &ray);\n"
"\n"
"	RayHit rayHit;\n"
"	Accelerator_Intersect(\n"
"		&ray,\n"
"		&rayHit\n"
"		ACCELERATOR_INTERSECT_PARAM\n"
"		);\n"
"\n"
"	// Write result\n"
"	__global RayHit *memRayHit = &rayHits[gid];\n"
"	memRayHit->t = rayHit.t;\n"
"	memRayHit->b1 = rayHit.b1;\n"
"	memRayHit->b2 = rayHit.b2;\n"
"	memRayHit->meshIndex = rayHit.meshIndex;\n"
"	memRayHit->triangleIndex = rayHit.triangleIndex;\n"
"}\n"
; } }
