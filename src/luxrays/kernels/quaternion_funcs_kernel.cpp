#include <string>
namespace luxrays { namespace ocl {
std::string KernelSource_quaternion_funcs = 
"#line 2 \"quaternion_funcs.cl\"\n"
"\n"
"/***************************************************************************\n"
" * Copyright 1998-2015 by authors (see AUTHORS.txt)                        *\n"
" *                                                                         *\n"
" *   This file is part of LuxRender.                                       *\n"
" *                                                                         *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");         *\n"
" * you may not use this file except in compliance with the License.        *\n"
" * You may obtain a copy of the License at                                 *\n"
" *                                                                         *\n"
" *     http://www.apache.org/licenses/LICENSE-2.0                          *\n"
" *                                                                         *\n"
" * Unless required by applicable law or agreed to in writing, software     *\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,       *\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*\n"
" * See the License for the specific language governing permissions and     *\n"
" * limitations under the License.                                          *\n"
" ***************************************************************************/\n"
"\n"
"// Get the rotation matrix from quaternion\n"
"void Quaternion_ToMatrix(const float4 q, Matrix4x4 *m) {\n"
"	const float xx = q.s1 * q.s1;\n"
"	const float yy = q.s2 * q.s2;\n"
"	const float zz = q.s3 * q.s3;\n"
"	const float xy = q.s1 * q.s2;\n"
"	const float xz = q.s1 * q.s3;\n"
"	const float yz = q.s2 * q.s3;\n"
"	const float xw = q.s1 * q.s0;\n"
"	const float yw = q.s2 * q.s0;\n"
"	const float zw = q.s3 * q.s0;\n"
"\n"
"	m->m[0][0] = 1.f - 2.f * (yy + zz);\n"
"	m->m[1][0] = 2.f * (xy - zw);\n"
"	m->m[2][0] = 2.f * (xz + yw);\n"
"	m->m[0][1] = 2.f * (xy + zw);\n"
"	m->m[1][1] = 1.f - 2.f * (xx + zz);\n"
"	m->m[2][1] = 2.f * (yz - xw);\n"
"	m->m[0][2] = 2.f * (xz - yw);\n"
"	m->m[1][2] = 2.f * (yz + xw);\n"
"	m->m[2][2] = 1.f - 2.f * (xx + yy);\n"
"\n"
"	// Complete matrix\n"
"	m->m[0][3] = m->m[1][3] = m->m[2][3] = 0.f;\n"
"	m->m[3][0] = m->m[3][1] = m->m[3][2] = 0.f;\n"
"	m->m[3][3] = 1.f;\n"
"}\n"
"\n"
"float4 Quaternion_Slerp(float t, const float4 q1, const float4 q2) {\n"
"\n"
"	float cos_phi = dot(q1, q2);\n"
"	const float sign = (cos_phi > 0.f) ? 1.f : -1.f;\n"
"	\n"
"	cos_phi *= sign;\n"
"\n"
"	float f1, f2;\n"
"	if (1.f - cos_phi > 1e-6f) {	\n"
"		float phi = acos(cos_phi);\n"
"		float sin_phi = sin(phi);	\n"
"		f1 = sin((1.f - t) * phi) / sin_phi;\n"
"		f2 = sin(t * phi) / sin_phi;\n"
"	} else {\n"
"		// start and end are very close\n"
"		// perform linear interpolation\n"
"		f1 = 1.f - t;\n"
"		f2 = t;\n"
"	}\n"
"\n"
"	return f1 * q1 + (sign * f2) * q2;\n"
"}\n"
; } }
