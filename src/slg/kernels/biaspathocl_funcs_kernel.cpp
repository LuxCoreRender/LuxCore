#include <string>
namespace slg { namespace ocl {
std::string KernelSource_biaspathocl_funcs = 
"#line 2 \"biaspathocl_funcs.cl\"\n"
"\n"
"/***************************************************************************\n"
" * Copyright 1998-2015 by authors (see AUTHORS.txt)                        *\n"
" *                                                                         *\n"
" *   This file is part of LuxRender.                                       *\n"
" *                                                                         *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");         *\n"
" * you may not use this file except in compliance with the License.        *\n"
" * You may obtain a copy of the License at                                 *\n"
" *                                                                         *\n"
" *     http://www.apache.org/licenses/LICENSE-2.0                          *\n"
" *                                                                         *\n"
" * Unless required by applicable law or agreed to in writing, software     *\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,       *\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*\n"
" * See the License for the specific language governing permissions and     *\n"
" * limitations under the License.                                          *\n"
" ***************************************************************************/\n"
"\n"
"#if defined(RENDER_ENGINE_RTBIASPATHOCL)\n"
"\n"
"// Morton decode from https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/\n"
"\n"
"// Inverse of Part1By1 - \"delete\" all odd-indexed bits\n"
"\n"
"uint Compact1By1(uint x) {\n"
"	x &= 0x55555555;					// x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0\n"
"	x = (x ^ (x >> 1)) & 0x33333333;	// x = --fe --dc --ba --98 --76 --54 --32 --10\n"
"	x = (x ^ (x >> 2)) & 0x0f0f0f0f;	// x = ---- fedc ---- ba98 ---- 7654 ---- 3210\n"
"	x = (x ^ (x >> 4)) & 0x00ff00ff;	// x = ---- ---- fedc ba98 ---- ---- 7654 3210\n"
"	x = (x ^ (x >> 8)) & 0x0000ffff;	// x = ---- ---- ---- ---- fedc ba98 7654 3210\n"
"	return x;\n"
"}\n"
"\n"
"// Inverse of Part1By2 - \"delete\" all bits not at positions divisible by 3\n"
"\n"
"uint Compact1By2(uint x) {\n"
"	x &= 0x09249249;					// x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0\n"
"	x = (x ^ (x >> 2)) & 0x030c30c3;	// x = ---- --98 ---- 76-- --54 ---- 32-- --10\n"
"	x = (x ^ (x >> 4)) & 0x0300f00f;	// x = ---- --98 ---- ---- 7654 ---- ---- 3210\n"
"	x = (x ^ (x >> 8)) & 0xff0000ff;	// x = ---- --98 ---- ---- ---- ---- 7654 3210\n"
"	x = (x ^ (x >> 16)) & 0x000003ff;	// x = ---- ---- ---- ---- ---- --98 7654 3210\n"
"	return x;\n"
"}\n"
"\n"
"uint DecodeMorton2X(const uint code) {\n"
"	return Compact1By1(code >> 0);\n"
"}\n"
"\n"
"uint DecodeMorton2Y(const uint code) {\n"
"	return Compact1By1(code >> 1);\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// RTBIASPATHOCL preview phase\n"
"//------------------------------------------------------------------------------\n"
"\n"
"uint RT_PreviewResolutionReduction(const uint pass) {\n"
"	return max(1, PARAM_RTBIASPATHOCL_PREVIEW_RESOLUTION_REDUCTION >>\n"
"			min(pass / PARAM_RTBIASPATHOCL_PREVIEW_RESOLUTION_REDUCTION_STEP, 16u));\n"
"}\n"
"\n"
"bool RT_IsPreview(const uint pass) {\n"
"	const uint previewResolutionReduction = RT_PreviewResolutionReduction(pass);\n"
"\n"
"	return (previewResolutionReduction >= PARAM_RTBIASPATHOCL_RESOLUTION_REDUCTION);\n"
"}\n"
"\n"
"void RT_GetSampleXY_PreviewResolutionReductionPhase(const uint pass,\n"
"		const uint tileTotalWidth,\n"
"		uint *samplePixelX, uint *samplePixelY) {\n"
"	const size_t gid = get_global_id(0);\n"
"	const uint previewResolutionReduction = RT_PreviewResolutionReduction(pass);\n"
"\n"
"	const uint samplePixelIndex = gid * previewResolutionReduction;\n"
"	*samplePixelX = samplePixelIndex % tileTotalWidth;\n"
"	*samplePixelY = samplePixelIndex / tileTotalWidth * previewResolutionReduction;\n"
"}\n"
"\n"
"void RT_GetSampleResultIndex_PreviewResolutionReductionPhase(const uint pass,\n"
"		const uint tileTotalWidth,\n"
"		const uint pixelX, const uint pixelY, uint *index) {\n"
"	const uint previewResolutionReduction = RT_PreviewResolutionReduction(pass);\n"
"\n"
"	*index = pixelX / previewResolutionReduction +\n"
"			(pixelY / previewResolutionReduction) * (tileTotalWidth / previewResolutionReduction);\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// RTBIASPATHOCL normal phase\n"
"//------------------------------------------------------------------------------\n"
"\n"
"void RT_GetSampleXY_ResolutionReductionPhase(const uint pass, const uint index,\n"
"		const uint tileTotalWidth, const uint tileTotalHeight,\n"
"		uint *samplePixelX, uint *samplePixelY) {\n"
"	// Rendering according a Morton curve\n"
"	const uint step = pass % (PARAM_RTBIASPATHOCL_RESOLUTION_REDUCTION * PARAM_RTBIASPATHOCL_RESOLUTION_REDUCTION);\n"
"	const uint mortonX = DecodeMorton2X(step);\n"
"	const uint mortonY = DecodeMorton2Y(step);\n"
"\n"
"	const uint samplePixelIndex = index * PARAM_RTBIASPATHOCL_RESOLUTION_REDUCTION;\n"
"\n"
"	*samplePixelX = samplePixelIndex % tileTotalWidth +\n"
"			mortonX;\n"
"	*samplePixelY = samplePixelIndex / tileTotalWidth * PARAM_RTBIASPATHOCL_RESOLUTION_REDUCTION +\n"
"			mortonY;\n"
"}\n"
"\n"
"bool RT_GetSampleResultIndex_ResolutionReductionPhase(const uint pass,\n"
"		const uint tileTotalWidth, const uint tileTotalHeight,\n"
"		const uint pixelX, const uint pixelY,\n"
"		uint *index) {\n"
"	*index = pixelX / PARAM_RTBIASPATHOCL_RESOLUTION_REDUCTION +\n"
"			(pixelY / PARAM_RTBIASPATHOCL_RESOLUTION_REDUCTION) * (tileTotalWidth / PARAM_RTBIASPATHOCL_RESOLUTION_REDUCTION);\n"
"\n"
"	uint samplePixelX, samplePixelY;\n"
"	RT_GetSampleXY_ResolutionReductionPhase(pass, *index, tileTotalWidth, tileTotalHeight, &samplePixelX, &samplePixelY);\n"
"\n"
"	// Check if it is one of the pixel rendered during this pass\n"
"	return ((pixelX == samplePixelX) && (pixelY == samplePixelY));\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// RTBIASPATHOCL long run phase\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if (PARAM_RTBIASPATHOCL_LONGRUN_RESOLUTION_REDUCTION_STEP > 0)\n"
"\n"
"uint RT_IsLongRun(const uint pass) {\n"
"	return (pass >=\n"
"			(1 << PARAM_RTBIASPATHOCL_PREVIEW_RESOLUTION_REDUCTION_STEP) +\n"
"			PARAM_RTBIASPATHOCL_RESOLUTION_REDUCTION * PARAM_RTBIASPATHOCL_RESOLUTION_REDUCTION *\n"
"				PARAM_RTBIASPATHOCL_LONGRUN_RESOLUTION_REDUCTION_STEP);\n"
"}\n"
"\n"
"void RT_GetSampleXY_LongRunResolutionReductionPhase(const uint pass, const uint index,\n"
"		const uint tileTotalWidth, const uint tileTotalHeight,\n"
"		uint *samplePixelX, uint *samplePixelY) {\n"
"	// Rendering according a Morton curve\n"
"	const uint step = pass % (PARAM_RTBIASPATHOCL_LONGRUN_RESOLUTION_REDUCTION * PARAM_RTBIASPATHOCL_LONGRUN_RESOLUTION_REDUCTION);\n"
"	const uint mortonX = DecodeMorton2X(step);\n"
"	const uint mortonY = DecodeMorton2Y(step);\n"
"\n"
"	const uint samplePixelIndex = index * PARAM_RTBIASPATHOCL_LONGRUN_RESOLUTION_REDUCTION;\n"
"\n"
"	*samplePixelX = samplePixelIndex % tileTotalWidth +\n"
"			mortonX;\n"
"	*samplePixelY = samplePixelIndex / tileTotalWidth * PARAM_RTBIASPATHOCL_LONGRUN_RESOLUTION_REDUCTION +\n"
"			mortonY;\n"
"}\n"
"\n"
"bool RT_GetSampleResultIndex_LongRunResolutionReductionPhase(const uint pass,\n"
"		const uint tileTotalWidth, const uint tileTotalHeight,\n"
"		const uint pixelX, const uint pixelY,\n"
"		uint *index) {\n"
"	*index = pixelX / PARAM_RTBIASPATHOCL_LONGRUN_RESOLUTION_REDUCTION +\n"
"			(pixelY / PARAM_RTBIASPATHOCL_LONGRUN_RESOLUTION_REDUCTION) * (tileTotalWidth / PARAM_RTBIASPATHOCL_LONGRUN_RESOLUTION_REDUCTION);\n"
"\n"
"	uint samplePixelX, samplePixelY;\n"
"	RT_GetSampleXY_LongRunResolutionReductionPhase(pass, *index, tileTotalWidth, tileTotalHeight, &samplePixelX, &samplePixelY);\n"
"\n"
"	// Check if it is one of the pixel rendered during this pass\n"
"	return ((pixelX == samplePixelX) && (pixelY == samplePixelY));\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"void GetSampleXY(const uint pass, const uint tileTotalWidth, const uint tileTotalHeight,\n"
"		uint *samplePixelX, uint *samplePixelY, uint *sampleIndex) {\n"
"	const size_t gid = get_global_id(0);\n"
"\n"
"#if defined(RENDER_ENGINE_RTBIASPATHOCL)\n"
"	// RTBIASPATHOCL renders first passes at a lower resolution:\n"
"	//   PARAM_RTBIASPATHOCL_PREVIEW_RESOLUTION_REDUCTION x PARAM_RTBIASPATHOCL_PREVIEW_RESOLUTION_REDUCTION\n"
"	// than renders one sample every:\n"
"	//   PARAM_RTBIASPATHOCL_RESOLUTION_REDUCTION x PARAM_RTBIASPATHOCL_RESOLUTION_REDUCTION\n"
"	// Than (optionally) renders:\n"
"	//   PARAM_RTBIASPATHOCL_LONGRUN_RESOLUTION_REDUCTION x PARAM_RTBIASPATHOCL_LONGRUN_RESOLUTION_REDUCTION\n"
"\n"
"	if (RT_IsPreview(pass))\n"
"		RT_GetSampleXY_PreviewResolutionReductionPhase(pass, tileTotalWidth, samplePixelX, samplePixelY);\n"
"	else {\n"
"#if (PARAM_RTBIASPATHOCL_LONGRUN_RESOLUTION_REDUCTION_STEP > 0)\n"
"		if (RT_IsLongRun(pass))\n"
"			RT_GetSampleXY_LongRunResolutionReductionPhase(pass, gid, tileTotalWidth, tileTotalHeight, samplePixelX, samplePixelY);\n"
"		else\n"
"#endif\n"
"			RT_GetSampleXY_ResolutionReductionPhase(pass, gid, tileTotalWidth, tileTotalHeight, samplePixelX, samplePixelY);\n"
"	}\n"
"\n"
"	*sampleIndex = 0;\n"
"#else\n"
"	// Normal BIASPATHOCL\n"
"	*sampleIndex = gid % (PARAM_AA_SAMPLES * PARAM_AA_SAMPLES);\n"
"	const uint samplePixelIndex = gid / (PARAM_AA_SAMPLES * PARAM_AA_SAMPLES);\n"
"	*samplePixelX = samplePixelIndex % tileTotalWidth;\n"
"	*samplePixelY = samplePixelIndex / tileTotalWidth;\n"
"#endif\n"
"}\n"
"\n"
"bool GetSampleResultIndex(const uint pass, const uint tileTotalWidth, const uint tileTotalHeight,\n"
"		const uint pixelX, const uint pixelY, uint *index) {\n"
"#if defined(RENDER_ENGINE_RTBIASPATHOCL)\n"
"	if (RT_IsPreview(pass)) {\n"
"		RT_GetSampleResultIndex_PreviewResolutionReductionPhase(pass,\n"
"				tileTotalWidth, pixelX, pixelY, index);\n"
"		return true;\n"
"	} else {\n"
"#if (PARAM_RTBIASPATHOCL_LONGRUN_RESOLUTION_REDUCTION_STEP > 0)\n"
"		if (RT_IsLongRun(pass)) {\n"
"			return RT_GetSampleResultIndex_LongRunResolutionReductionPhase(pass,\n"
"					tileTotalWidth, tileTotalHeight, pixelX, pixelY, index);\n"
"		} else\n"
"#endif\n"
"		{\n"
"			return RT_GetSampleResultIndex_ResolutionReductionPhase(pass,\n"
"					tileTotalWidth, tileTotalHeight, pixelX, pixelY, index);\n"
"		}\n"
"	}\n"
"#else\n"
"	// Normal BIASPATHOCL\n"
"	const size_t gid = get_global_id(0);\n"
"	*index = gid * PARAM_AA_SAMPLES * PARAM_AA_SAMPLES;\n"
"\n"
"	return true;\n"
"#endif	\n"
"}\n"
"\n"
"void SampleGrid(Seed *seed, const uint size,\n"
"		const uint ix, const uint iy, float *u0, float *u1) {\n"
"	*u0 = Rnd_FloatValue(seed);\n"
"	*u1 = Rnd_FloatValue(seed);\n"
"\n"
"	// RTBIASPATHOCL uses a plain random sampler\n"
"#if !defined(RENDER_ENGINE_RTBIASPATHOCL)\n"
"	if (size > 1) {\n"
"		const float idim = 1.f / size;\n"
"		*u0 = (ix + *u0) * idim;\n"
"		*u1 = (iy + *u1) * idim;\n"
"	}\n"
"#endif\n"
"}\n"
"\n"
"typedef struct {\n"
"	uint depth, diffuseDepth, glossyDepth, specularDepth;\n"
"} PathDepthInfo;\n"
"\n"
"void PathDepthInfo_Init(PathDepthInfo *depthInfo) {\n"
"	depthInfo->depth = 0;\n"
"	depthInfo->diffuseDepth = 0;\n"
"	depthInfo->glossyDepth = 0;\n"
"	depthInfo->specularDepth = 0;\n"
"}\n"
"\n"
"void PathDepthInfo_IncDepths(PathDepthInfo *depthInfo, const BSDFEvent event) {\n"
"	++(depthInfo->depth);\n"
"	if (event & DIFFUSE)\n"
"		++(depthInfo->diffuseDepth);\n"
"	if (event & GLOSSY)\n"
"		++(depthInfo->glossyDepth);\n"
"	if (event & SPECULAR)\n"
"		++(depthInfo->specularDepth);\n"
"}\n"
"\n"
"bool PathDepthInfo_IsLastPathVertex(const PathDepthInfo *depthInfo, const BSDFEvent event) {\n"
"	return (depthInfo->depth + 1 == PARAM_DEPTH_MAX) ||\n"
"			((event & DIFFUSE) && (depthInfo->diffuseDepth + 1 == PARAM_DEPTH_DIFFUSE_MAX)) ||\n"
"			((event & GLOSSY) && (depthInfo->glossyDepth + 1 == PARAM_DEPTH_GLOSSY_MAX)) ||\n"
"			((event & SPECULAR) && (depthInfo->specularDepth + 1 == PARAM_DEPTH_SPECULAR_MAX));\n"
"}\n"
"\n"
"bool PathDepthInfo_CheckComponentDepths(const BSDFEvent component) {\n"
"	return ((component & DIFFUSE) && (PARAM_DEPTH_DIFFUSE_MAX > 0)) ||\n"
"			((component & GLOSSY) && (PARAM_DEPTH_GLOSSY_MAX > 0)) ||\n"
"			((component & SPECULAR) && (PARAM_DEPTH_SPECULAR_MAX > 0));\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"void GenerateCameraRay(\n"
"		Seed *seed,\n"
"		__global GPUTask *task,\n"
"		__global SampleResult *sampleResult,\n"
"		__global const Camera* restrict camera,\n"
"		__global float *pixelFilterDistribution,\n"
"		const uint sampleX, const uint sampleY, const int sampleIndex,\n"
"		const uint tileStartX, const uint tileStartY, \n"
"		const uint engineFilmWidth, const uint engineFilmHeight,\n"
"		Ray *ray) {\n"
"	//if (get_global_id(0) == 0)\n"
"	//	printf(\"tileSampleIndex: %d (%d, %d)\\n\", sampleIndex, sampleIndex % PARAM_AA_SAMPLES, sampleIndex / PARAM_AA_SAMPLES);\n"
"\n"
"	float u0, u1;\n"
"	SampleGrid(seed, PARAM_AA_SAMPLES,\n"
"			sampleIndex % PARAM_AA_SAMPLES, sampleIndex / PARAM_AA_SAMPLES,\n"
"			&u0, &u1);\n"
"\n"
"	// Sample according the pixel filter distribution\n"
"	FilterDistribution_SampleContinuous(pixelFilterDistribution, u0, u1, &u0, &u1);\n"
"\n"
"	const float filmX = sampleX + .5f + u0;\n"
"	const float filmY = sampleY + .5f + u1;\n"
"	sampleResult->filmX = filmX;\n"
"	sampleResult->filmY = filmY;\n"
"\n"
"	const float dofSampleX = Rnd_FloatValue(seed);\n"
"	const float dofSampleY = Rnd_FloatValue(seed);\n"
"\n"
"	Camera_GenerateRay(camera, engineFilmWidth, engineFilmHeight, ray,\n"
"			tileStartX + filmX, tileStartY + filmY, Rnd_FloatValue(seed),\n"
"			dofSampleX, dofSampleY);\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"uint BIASPATHOCL_Scene_Intersect(\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		__global PathVolumeInfo *volInfo,\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		const float initialPassThrough,\n"
"#endif\n"
"#if !defined(RENDER_ENGINE_BIASPATHOCL) && !defined(RENDER_ENGINE_RTBIASPATHOCL)\n"
"		__global\n"
"#endif\n"
"		Ray *ray,\n"
"#if !defined(RENDER_ENGINE_BIASPATHOCL) && !defined(RENDER_ENGINE_RTBIASPATHOCL)\n"
"		__global\n"
"#endif\n"
"		RayHit *rayHit,\n"
"		__global BSDF *bsdf,\n"
"		float3 *connectionThroughput,  const float3 pathThroughput,\n"
"		__global SampleResult *sampleResult,\n"
"		// BSDF_Init parameters\n"
"		__global const Mesh* restrict meshDescs,\n"
"		__global const SceneObject* restrict sceneObjs,\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		__global const uint *meshTriLightDefsOffset,\n"
"#endif\n"
"		__global const Point* restrict vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"		__global const Vector *vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"		__global const UV* restrict vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"		__global const Spectrum* restrict vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"		__global const float* restrict vertAlphas,\n"
"#endif\n"
"		__global const Triangle* restrict triangles\n"
"		MATERIALS_PARAM_DECL\n"
"		// Accelerator_Intersect parameters\n"
"		ACCELERATOR_INTERSECT_PARAM_DECL\n"
"		) {\n"
"	*connectionThroughput = WHITE;\n"
"	uint tracedRaysCount = 0;\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"	float passThrough = initialPassThrough;\n"
"#endif\n"
"\n"
"	for (;;) {\n"
"		Accelerator_Intersect(ray, rayHit\n"
"			ACCELERATOR_INTERSECT_PARAM);\n"
"		++tracedRaysCount;\n"
"\n"
"		float3 connectionSegmentThroughput;\n"
"		const bool continueToTrace = Scene_Intersect(\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"			volInfo,\n"
"			tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"			passThrough,\n"
"#endif\n"
"			ray, rayHit, bsdf,\n"
"			&connectionSegmentThroughput, pathThroughput * (*connectionThroughput),\n"
"			sampleResult,\n"
"			// BSDF_Init parameters\n"
"			meshDescs,\n"
"			sceneObjs,\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"			meshTriLightDefsOffset,\n"
"#endif\n"
"			vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"			vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"			vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"			vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"			vertAlphas,\n"
"#endif\n"
"			triangles\n"
"			MATERIALS_PARAM\n"
"			);\n"
"		*connectionThroughput *= connectionSegmentThroughput;\n"
"		if (!continueToTrace)\n"
"			break;\n"
"\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		// I generate a new random variable starting from the previous one. I'm\n"
"		// not really sure about the kind of correlation introduced by this\n"
"		// trick.\n"
"		passThrough = fabs(passThrough - .5f) * 2.f;\n"
"#endif\n"
"	}\n"
"	\n"
"	return tracedRaysCount;\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Direct hit  on lights\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"void DirectHitFiniteLight(\n"
"		const BSDFEvent lastBSDFEvent,\n"
"		const float3 pathThroughput, const float distance, __global BSDF *bsdf,\n"
"		const float lastPdfW, __global SampleResult *sampleResult\n"
"		LIGHTS_PARAM_DECL) {\n"
"	if (sampleResult->firstPathVertex ||\n"
"			(lights[bsdf->triangleLightSourceIndex].visibility &\n"
"			(sampleResult->firstPathVertexEvent & (DIFFUSE | GLOSSY | SPECULAR)))) {\n"
"		float directPdfA;\n"
"		const float3 emittedRadiance = BSDF_GetEmittedRadiance(bsdf, &directPdfA\n"
"				LIGHTS_PARAM);\n"
"\n"
"		if (!Spectrum_IsBlack(emittedRadiance)) {\n"
"			// Add emitted radiance\n"
"			float weight = 1.f;\n"
"			if (!(lastBSDFEvent & SPECULAR)) {\n"
"				const float lightPickProb = Scene_SampleAllLightPdf(lightsDistribution,\n"
"						lights[bsdf->triangleLightSourceIndex].lightSceneIndex);\n"
"				const float directPdfW = PdfAtoW(directPdfA, distance,\n"
"					fabs(dot(VLOAD3F(&bsdf->hitPoint.fixedDir.x), VLOAD3F(&bsdf->hitPoint.shadeN.x))));\n"
"\n"
"				// MIS between BSDF sampling and direct light sampling\n"
"				weight = PowerHeuristic(lastPdfW, directPdfW * lightPickProb);\n"
"			}\n"
"\n"
"			SampleResult_AddEmission(sampleResult, BSDF_GetLightID(bsdf\n"
"					MATERIALS_PARAM), pathThroughput, weight * emittedRadiance);\n"
"		}\n"
"	}\n"
"}\n"
"#endif\n"
"\n"
"#if defined(PARAM_HAS_ENVLIGHTS)\n"
"void DirectHitInfiniteLight(\n"
"		const BSDFEvent lastBSDFEvent,\n"
"		const float3 pathThroughput,\n"
"		const float3 eyeDir, const float lastPdfW,\n"
"		__global SampleResult *sampleResult\n"
"		LIGHTS_PARAM_DECL) {\n"
"	for (uint i = 0; i < envLightCount; ++i) {\n"
"		__global const LightSource* restrict light = &lights[envLightIndices[i]];\n"
"\n"
"		if (sampleResult->firstPathVertex || (light->visibility & (sampleResult->firstPathVertexEvent & (DIFFUSE | GLOSSY | SPECULAR)))) {\n"
"			float directPdfW;\n"
"			const float3 envRadiance = EnvLight_GetRadiance(light, eyeDir, &directPdfW\n"
"					LIGHTS_PARAM);\n"
"\n"
"			if (!Spectrum_IsBlack(envRadiance)) {\n"
"				// MIS between BSDF sampling and direct light sampling\n"
"				const float lightPickProb = Scene_SampleAllLightPdf(lightsDistribution, light->lightSceneIndex);\n"
"				const float weight = ((lastBSDFEvent & SPECULAR) ? 1.f : PowerHeuristic(lastPdfW, directPdfW * lightPickProb));\n"
"\n"
"				SampleResult_AddEmission(sampleResult, light->lightID, pathThroughput, weight * envRadiance);\n"
"			}\n"
"		}\n"
"	}\n"
"}\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Direct light sampling\n"
"//------------------------------------------------------------------------------\n"
"\n"
"bool DirectLightSamplingInit(\n"
"		__global const LightSource* restrict light,\n"
"		const float lightPickPdf,\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"		const float time, const float u0, const float u1,\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		const float passThroughEvent,\n"
"#endif\n"
"		__global BSDF *bsdf, BSDFEvent *event,\n"
"		__global SampleResult *sampleResult,\n"
"		Ray *shadowRay,\n"
"		float3 *radiance,\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"		float3 *irradiance,\n"
"#endif\n"
"		uint *ID\n"
"		LIGHTS_PARAM_DECL) {\n"
"	float3 lightRayDir;\n"
"	float distance, directPdfW;\n"
"	const float3 lightRadiance = Light_Illuminate(\n"
"			light,\n"
"			VLOAD3F(&bsdf->hitPoint.p.x),\n"
"			u0, u1,\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"			passThroughEvent,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"			worldCenterX, worldCenterY, worldCenterZ, worldRadius,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"			tmpHitPoint,\n"
"#endif		\n"
"			&lightRayDir, &distance, &directPdfW\n"
"			LIGHTS_PARAM);\n"
"\n"
"	// Setup the shadow ray\n"
"	const float cosThetaToLight = fabs(dot(lightRayDir, VLOAD3F(&bsdf->hitPoint.shadeN.x)));\n"
"	if (((Spectrum_Y(lightRadiance) * cosThetaToLight / directPdfW) > PARAM_LOW_LIGHT_THREASHOLD) &&\n"
"			(distance > PARAM_NEAR_START_LIGHT)) {\n"
"		float bsdfPdfW;\n"
"		const float3 bsdfEval = BSDF_Evaluate(bsdf,\n"
"				lightRayDir, event, &bsdfPdfW\n"
"				MATERIALS_PARAM);\n"
"\n"
"		if (!Spectrum_IsBlack(bsdfEval)) {\n"
"			const float directLightSamplingPdfW = directPdfW * lightPickPdf;\n"
"			const float factor = 1.f / directLightSamplingPdfW;\n"
"\n"
"			// MIS between direct light sampling and BSDF sampling\n"
"			const float weight = (!sampleResult->lastPathVertex && Light_IsEnvOrIntersectable(light)) ?\n"
"				PowerHeuristic(directLightSamplingPdfW, bsdfPdfW) : 1.f;\n"
"\n"
"			*radiance = bsdfEval * (weight * factor) * lightRadiance;\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"			*irradiance = factor * lightRadiance;\n"
"#endif\n"
"			*ID = light->lightID;\n"
"\n"
"			// Setup the shadow ray\n"
"			const float3 hitPoint = VLOAD3F(&bsdf->hitPoint.p.x);\n"
"			Ray_Init4_Private(shadowRay, hitPoint, lightRayDir, 0.f, distance, time);\n"
"\n"
"			return true;\n"
"		}\n"
"	}\n"
"\n"
"	return false;\n"
"}\n"
"\n"
"uint DirectLightSampling_ONE(\n"
"		Seed *seed,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		__global PathVolumeInfo *volInfo,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0) || defined(PARAM_HAS_VOLUMES)\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"		const float time,\n"
"		const float3 pathThroughput,\n"
"		__global BSDF *bsdf, __global BSDF *directLightBSDF,\n"
"		__global SampleResult *sampleResult,\n"
"		// BSDF_Init parameters\n"
"		__global const Mesh* restrict meshDescs,\n"
"		__global const SceneObject* restrict sceneObjs,\n"
"		__global const Point* restrict vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"		__global const Vector* restrict vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"		__global const UV* restrict vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"		__global const Spectrum* restrict vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"		__global const float* restrict vertAlphas,\n"
"#endif\n"
"		__global const Triangle* restrict triangles,\n"
"		bool *isLightVisible\n"
"\n"
"		// Accelerator_Intersect parameters\n"
"		ACCELERATOR_INTERSECT_PARAM_DECL\n"
"		// Light related parameters\n"
"		LIGHTS_PARAM_DECL) {\n"
"	// ONE direct light sampling strategy\n"
"\n"
"	*isLightVisible = false;\n"
"\n"
"	// Select the light strategy to use\n"
"	__global const float* restrict lightDist = BSDF_IsShadowCatcherOnlyInfiniteLights(bsdf MATERIALS_PARAM) ?\n"
"		infiniteLightSourcesDistribution : lightsDistribution;\n"
"\n"
"	// Pick a light source to sample\n"
"	float lightPickPdf;\n"
"	const uint lightIndex = Scene_SampleAllLights(lightDist, Rnd_FloatValue(seed), &lightPickPdf);\n"
"\n"
"	Ray shadowRay;\n"
"	uint lightID;\n"
"	BSDFEvent event;\n"
"	float3 lightRadiance;\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"	float3 lightIrradiance;\n"
"#endif\n"
"	const bool illuminated = DirectLightSamplingInit(\n"
"		&lights[lightIndex],\n"
"		lightPickPdf,\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"		worldCenterX,\n"
"		worldCenterY,\n"
"		worldCenterZ,\n"
"		worldRadius,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		tmpHitPoint,\n"
"#endif\n"
"		time, Rnd_FloatValue(seed), Rnd_FloatValue(seed),\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		Rnd_FloatValue(seed),\n"
"#endif\n"
"		bsdf, &event, sampleResult,\n"
"		&shadowRay, &lightRadiance,\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"		&lightIrradiance,\n"
"#endif\n"
"		&lightID\n"
"		LIGHTS_PARAM);\n"
"\n"
"	uint tracedRaysCount = 0;\n"
"	if (illuminated) {\n"
"		// Trace the shadow ray\n"
"\n"
"		float3 connectionThroughput;\n"
"		RayHit shadowRayHit;\n"
"		tracedRaysCount += BIASPATHOCL_Scene_Intersect(\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"				volInfo,\n"
"				tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"				Rnd_FloatValue(seed),\n"
"#endif\n"
"				&shadowRay, &shadowRayHit,\n"
"				directLightBSDF,\n"
"				&connectionThroughput, pathThroughput,\n"
"				sampleResult,\n"
"				// BSDF_Init parameters\n"
"				meshDescs,\n"
"				sceneObjs,\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"				meshTriLightDefsOffset,\n"
"#endif\n"
"				vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"				vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"				vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"				vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"				vertAlphas,\n"
"#endif\n"
"				triangles\n"
"				MATERIALS_PARAM\n"
"				// Accelerator_Intersect parameters\n"
"				ACCELERATOR_INTERSECT_PARAM\n"
"				);\n"
"\n"
"		if (shadowRayHit.meshIndex == NULL_INDEX) {\n"
"			// Nothing was hit, the light source is visible\n"
"			\n"
"			if (!BSDF_IsShadowCatcher(bsdf MATERIALS_PARAM)) {\n"
"				SampleResult_AddDirectLight(sampleResult, lightID, event, pathThroughput,\n"
"						connectionThroughput * lightRadiance, 1.f);\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"				// The first path vertex is not handled by AddDirectLight(). This is valid\n"
"				// for irradiance AOV only if it is not a SPECULAR material and first path vertex\n"
"				if ((sampleResult->firstPathVertex) && !(BSDF_GetEventTypes(bsdf\n"
"							MATERIALS_PARAM) & SPECULAR))\n"
"					VSTORE3F(VLOAD3F(sampleResult->irradiance.c) +\n"
"							M_1_PI_F * fabs(dot(VLOAD3F(&bsdf->hitPoint.shadeN.x),\n"
"							(float3)(shadowRay.d.x, shadowRay.d.y, shadowRay.d.z))) *\n"
"								connectionThroughput * lightIrradiance,\n"
"							sampleResult->irradiance.c);\n"
"#endif\n"
"			}\n"
"\n"
"			*isLightVisible = true;\n"
"		}\n"
"	}\n"
"\n"
"	return tracedRaysCount;\n"
"}\n"
"\n"
"uint DirectLightSampling_ALL(\n"
"		Seed *seed,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		__global PathVolumeInfo *volInfo,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0) || defined(PARAM_HAS_VOLUMES)\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"		const float time,\n"
"		const float3 pathThroughput,\n"
"		__global BSDF *bsdf, __global BSDF *directLightBSDF,\n"
"		__global SampleResult *sampleResult,\n"
"		// BSDF_Init parameters\n"
"		__global const Mesh* restrict meshDescs,\n"
"		__global const SceneObject* restrict sceneObjs,\n"
"		__global const Point* restrict vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"		__global const Vector* restrict vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"		__global const UV* restrict vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"		__global const Spectrum* restrict vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"		__global const float* restrict vertAlphas,\n"
"#endif\n"
"		__global const Triangle* restrict triangles,\n"
"		float *lightsVisibility\n"
"		// Accelerator_Intersect parameters\n"
"		ACCELERATOR_INTERSECT_PARAM_DECL\n"
"		// Light related parameters\n"
"		LIGHTS_PARAM_DECL) {\n"
"	// Select the light strategy to use\n"
"	__global const float* restrict lightDist = BSDF_IsShadowCatcherOnlyInfiniteLights(bsdf MATERIALS_PARAM) ?\n"
"		infiniteLightSourcesDistribution : lightsDistribution;\n"
"\n"
"	uint tracedRaysCount = 0;\n"
"	*lightsVisibility = 0.f;\n"
"	uint totalSampleCount = 0;\n"
"\n"
"	for (uint samples = 0; samples < PARAM_FIRST_VERTEX_DL_COUNT; ++samples) {\n"
"		// Pick a light source to sample\n"
"		float lightPickPdf;\n"
"		const uint lightIndex = Scene_SampleAllLights(lightsDistribution, Rnd_FloatValue(seed), &lightPickPdf);\n"
"\n"
"		__global const LightSource* restrict light = &lights[lightIndex];\n"
"		const int lightSamplesCount = light->samples;\n"
"		const uint sampleCount = (lightSamplesCount < 0) ? PARAM_DIRECT_LIGHT_SAMPLES : (uint)lightSamplesCount;\n"
"		const uint sampleCount2 = sampleCount * sampleCount;\n"
"\n"
"		const float scaleFactor = 1.f / (sampleCount2 * PARAM_FIRST_VERTEX_DL_COUNT);\n"
"		for (uint currentLightSampleIndex = 0; currentLightSampleIndex < sampleCount2; ++currentLightSampleIndex) {\n"
"			float u0, u1;\n"
"			SampleGrid(seed, sampleCount,\n"
"					currentLightSampleIndex % sampleCount, currentLightSampleIndex / sampleCount,\n"
"					&u0, &u1);\n"
"\n"
"			Ray shadowRay;\n"
"			float3 lightRadiance;\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"			float3 lightIrradiance;\n"
"#endif\n"
"			uint lightID;\n"
"			BSDFEvent event;\n"
"			const bool illuminated = DirectLightSamplingInit(\n"
"				light,\n"
"				lightPickPdf,\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"				worldCenterX,\n"
"				worldCenterY,\n"
"				worldCenterZ,\n"
"				worldRadius,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"				tmpHitPoint,\n"
"#endif\n"
"				time, u0, u1,\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"				Rnd_FloatValue(seed),\n"
"#endif\n"
"				bsdf, &event, sampleResult,\n"
"				&shadowRay, &lightRadiance,\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"				&lightIrradiance,\n"
"#endif\n"
"				&lightID\n"
"				LIGHTS_PARAM);\n"
"\n"
"			if (illuminated) {\n"
"				// Trace the shadow ray\n"
"\n"
"				float3 connectionThroughput;\n"
"				RayHit shadowRayHit;\n"
"				tracedRaysCount += BIASPATHOCL_Scene_Intersect(\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"						volInfo,\n"
"						tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"						Rnd_FloatValue(seed),\n"
"#endif\n"
"						&shadowRay, &shadowRayHit,\n"
"						directLightBSDF,\n"
"						&connectionThroughput, pathThroughput,\n"
"						sampleResult,\n"
"						// BSDF_Init parameters\n"
"						meshDescs,\n"
"						sceneObjs,\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"						meshTriLightDefsOffset,\n"
"#endif\n"
"						vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"						vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"						vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"						vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"						vertAlphas,\n"
"#endif\n"
"						triangles\n"
"						MATERIALS_PARAM\n"
"						// Accelerator_Intersect parameters\n"
"						ACCELERATOR_INTERSECT_PARAM\n"
"						);\n"
"\n"
"				if (shadowRayHit.meshIndex == NULL_INDEX) {\n"
"					// Nothing was hit, the light source is visible\n"
"\n"
"					if (!BSDF_IsShadowCatcher(bsdf MATERIALS_PARAM)) {\n"
"						// Nothing was hit, the light source is visible\n"
"						const float3 incomingRadiance = scaleFactor * connectionThroughput * lightRadiance;\n"
"						SampleResult_AddDirectLight(sampleResult, lightID, event,\n"
"								pathThroughput, incomingRadiance, scaleFactor);\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"						// The first path vertex is not handled by AddDirectLight(). This is valid\n"
"						// for irradiance AOV only if it is not a SPECULAR material and first path vertex\n"
"						if ((sampleResult->firstPathVertex) && !(BSDF_GetEventTypes(bsdf\n"
"									MATERIALS_PARAM) & SPECULAR))\n"
"							VSTORE3F(VLOAD3F(sampleResult->irradiance.c) +\n"
"									(M_1_PI_F * fabs(dot(VLOAD3F(&bsdf->hitPoint.shadeN.x),\n"
"									(float3)(shadowRay.d.x, shadowRay.d.y, shadowRay.d.z))) * scaleFactor) *\n"
"										connectionThroughput * lightIrradiance,\n"
"									sampleResult->irradiance.c);\n"
"#endif\n"
"					}\n"
"\n"
"					*lightsVisibility += 1.f;\n"
"				}\n"
"			}\n"
"		}\n"
"\n"
"		totalSampleCount += sampleCount2;\n"
"	}\n"
"	\n"
"	*lightsVisibility /= totalSampleCount;\n"
"\n"
"	return tracedRaysCount;\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Indirect light sampling\n"
"//------------------------------------------------------------------------------\n"
"\n"
"uint ContinueTracePath(\n"
"		Seed *seed,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		__global PathVolumeInfo *volInfoPathVertexN,\n"
"		__global PathVolumeInfo *directLightVolInfo,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0) || defined(PARAM_HAS_VOLUMES)\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"		PathDepthInfo *depthInfo,\n"
"		Ray *ray,\n"
"		const float time,\n"
"		float3 pathThroughput,\n"
"		BSDFEvent lastBSDFEvent, float lastPdfW,\n"
"		__global BSDF *bsdfPathVertexN, __global BSDF *directLightBSDF,\n"
"		__global SampleResult *sampleResult,\n"
"		// BSDF_Init parameters\n"
"		__global const Mesh* restrict meshDescs,\n"
"		__global const SceneObject* restrict sceneObjs,\n"
"		__global const Point* restrict vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"		__global const Vector* restrict vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"		__global const UV* restrict vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"		__global const Spectrum* restrict vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"		__global const float* restrict vertAlphas,\n"
"#endif\n"
"		__global const Triangle* restrict triangles\n"
"		// Accelerator_Intersect parameters\n"
"		ACCELERATOR_INTERSECT_PARAM_DECL\n"
"		// Light related parameters\n"
"		LIGHTS_PARAM_DECL) {\n"
"	uint tracedRaysCount = 0;\n"
"\n"
"	for (;;) {\n"
"		//----------------------------------------------------------------------\n"
"		// Trace the ray\n"
"		//----------------------------------------------------------------------\n"
"\n"
"		float3 connectionThroughput;\n"
"		RayHit rayHit;\n"
"		tracedRaysCount += BIASPATHOCL_Scene_Intersect(\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"			volInfoPathVertexN,\n"
"			tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"			Rnd_FloatValue(seed),\n"
"#endif\n"
"			ray, &rayHit,\n"
"			bsdfPathVertexN,\n"
"			&connectionThroughput, pathThroughput,\n"
"			sampleResult,\n"
"			// BSDF_Init parameters\n"
"			meshDescs,\n"
"			sceneObjs,\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"			meshTriLightDefsOffset,\n"
"#endif\n"
"			vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"			vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"			vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"			vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"			vertAlphas,\n"
"#endif\n"
"			triangles\n"
"			MATERIALS_PARAM\n"
"			// Accelerator_Intersect parameters\n"
"			ACCELERATOR_INTERSECT_PARAM);\n"
"		pathThroughput *= connectionThroughput;\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"		// Update also irradiance AOV path throughput\n"
"		VSTORE3F(VLOAD3F(sampleResult->irradiancePathThroughput.c) * connectionThroughput, sampleResult->irradiancePathThroughput.c);\n"
"#endif\n"
"\n"
"		if (rayHit.meshIndex == NULL_INDEX) {\n"
"			// Nothing was hit, look for env. lights\n"
"\n"
"#if defined(PARAM_HAS_ENVLIGHTS)\n"
"#if defined(PARAM_FORCE_BLACK_BACKGROUND)\n"
"			if (!sampleResult->passThroughPath) {\n"
"#endif\n"
"				// Add environmental lights radiance\n"
"				const float3 rayDir = (float3)(ray->d.x, ray->d.y, ray->d.z);\n"
"				DirectHitInfiniteLight(\n"
"						lastBSDFEvent,\n"
"						pathThroughput,\n"
"						-rayDir, lastPdfW,\n"
"						sampleResult\n"
"						LIGHTS_PARAM);\n"
"#if defined(PARAM_FORCE_BLACK_BACKGROUND)\n"
"			}\n"
"#endif\n"
"#endif\n"
"\n"
"			break;\n"
"		}\n"
"\n"
"		// Something was hit\n"
"\n"
"		// Check if it is visible in indirect paths\n"
"		if (!(mats[bsdfPathVertexN->materialIndex].visibility &\n"
"				(sampleResult->firstPathVertexEvent & (DIFFUSE | GLOSSY | SPECULAR))))\n"
"			break;\n"
"\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		// Check if it is a light source (note: I can hit only triangle area light sources)\n"
"		if (BSDF_IsLightSource(bsdfPathVertexN) && (rayHit.t > PARAM_NEAR_START_LIGHT)) {\n"
"			DirectHitFiniteLight(lastBSDFEvent,\n"
"					pathThroughput,\n"
"					rayHit.t, bsdfPathVertexN, lastPdfW,\n"
"					sampleResult\n"
"					LIGHTS_PARAM);\n"
"		}\n"
"#endif\n"
"\n"
"		//------------------------------------------------------------------\n"
"		// Direct light sampling\n"
"		//------------------------------------------------------------------\n"
"\n"
"		// I avoid to do DL on the last vertex otherwise it introduces a lot of\n"
"		// noise because I can not use MIS\n"
"		sampleResult->lastPathVertex = PathDepthInfo_IsLastPathVertex(depthInfo,\n"
"				BSDF_GetEventTypes(bsdfPathVertexN\n"
"					MATERIALS_PARAM));\n"
"		if (sampleResult->lastPathVertex)\n"
"			break;\n"
"\n"
"		bool isLightVisible = false;\n"
"\n"
"		// Only if it is not a SPECULAR BSDF\n"
"		if (!BSDF_IsDelta(bsdfPathVertexN\n"
"				MATERIALS_PARAM)) {\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"			// I need to work on a copy of volume information of the path vertex\n"
"			*directLightVolInfo = *volInfoPathVertexN;\n"
"#endif\n"
"\n"
"			tracedRaysCount += DirectLightSampling_ONE(\n"
"				seed,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"				directLightVolInfo,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0) || defined(PARAM_HAS_VOLUMES)\n"
"				tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"				worldCenterX, worldCenterY, worldCenterZ, worldRadius,\n"
"#endif\n"
"				time,\n"
"				pathThroughput,\n"
"				bsdfPathVertexN, directLightBSDF,\n"
"				sampleResult,\n"
"				// BSDF_Init parameters\n"
"				meshDescs,\n"
"				sceneObjs,\n"
"				vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"				vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"				vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"				vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"				vertAlphas,\n"
"#endif\n"
"				triangles,\n"
"				&isLightVisible\n"
"				// Accelerator_Intersect parameters\n"
"				ACCELERATOR_INTERSECT_PARAM\n"
"				// Light related parameters\n"
"				LIGHTS_PARAM);\n"
"		}\n"
"\n"
"		//------------------------------------------------------------------\n"
"		// Build the next path vertex ray\n"
"		//------------------------------------------------------------------\n"
"\n"
"		float3 sampledDir;\n"
"		float cosSampledDir;\n"
"		float3 bsdfSample;\n"
"\n"
"		if (BSDF_IsShadowCatcher(bsdfPathVertexN MATERIALS_PARAM) && isLightVisible) {\n"
"			bsdfSample = BSDF_ShadowCatcherSample(bsdfPathVertexN,\n"
"					&sampledDir, &lastPdfW, &cosSampledDir, &lastBSDFEvent\n"
"					MATERIALS_PARAM);\n"
"		} else {\n"
"			bsdfSample = BSDF_Sample(bsdfPathVertexN,\n"
"					Rnd_FloatValue(seed),\n"
"					Rnd_FloatValue(seed),\n"
"					&sampledDir, &lastPdfW, &cosSampledDir, &lastBSDFEvent,\n"
"					ALL\n"
"					MATERIALS_PARAM);\n"
"			sampleResult->passThroughPath = false;\n"
"		}\n"
"\n"
"		if (Spectrum_IsBlack(bsdfSample))\n"
"			break;\n"
"\n"
"		// Increment path depth informations\n"
"		PathDepthInfo_IncDepths(depthInfo, lastBSDFEvent);\n"
"\n"
"		// Update volume information\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		PathVolumeInfo_Update(volInfoPathVertexN, lastBSDFEvent, bsdfPathVertexN\n"
"				MATERIALS_PARAM);\n"
"#endif\n"
"\n"
"		// Continue to trace the path\n"
"		const float3 throughputFactor = bsdfSample *\n"
"			((lastBSDFEvent & SPECULAR) ? 1.f : min(1.f, lastPdfW / PARAM_PDF_CLAMP_VALUE));\n"
"		pathThroughput *= throughputFactor;\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"		// Update also irradiance AOV path throughput\n"
"		VSTORE3F(VLOAD3F(sampleResult->irradiancePathThroughput.c) * throughputFactor, sampleResult->irradiancePathThroughput.c);\n"
"#endif\n"
"\n"
"		Ray_Init2_Private(ray, VLOAD3F(&bsdfPathVertexN->hitPoint.p.x), sampledDir, time);\n"
"	}\n"
"\n"
"	return tracedRaysCount;\n"
"}\n"
"\n"
"uint SampleComponent(\n"
"		Seed *seed,\n"
"		const float lightsVisibility,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		__global PathVolumeInfo *volInfoPathVertex1,\n"
"		__global PathVolumeInfo *volInfoPathVertexN,\n"
"		__global PathVolumeInfo *directLightVolInfo,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0) || defined(PARAM_HAS_VOLUMES)\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"		const float time,\n"
"		const BSDFEvent requestedEventTypes,\n"
"		const uint size,\n"
"		const float3 throughputPathVertex1,\n"
"		__global BSDF *bsdfPathVertex1, __global BSDF *bsdfPathVertexN,\n"
"		__global BSDF *directLightBSDF,\n"
"		__global SampleResult *sampleResult,\n"
"		// BSDF_Init parameters\n"
"		__global const Mesh* restrict meshDescs,\n"
"		__global const SceneObject* restrict sceneObjs,\n"
"		__global const Point* restrict vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"		__global const Vector* restrict vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"		__global const UV* restrict vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"		__global const Spectrum* restrict vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"		__global const float* restrict vertAlphas,\n"
"#endif\n"
"		__global const Triangle* restrict triangles\n"
"		// Accelerator_Intersect parameters\n"
"		ACCELERATOR_INTERSECT_PARAM_DECL\n"
"		// Light related parameters\n"
"		LIGHTS_PARAM_DECL) {\n"
"	uint tracedRaysCount = 0;\n"
"\n"
"	const uint sampleCount = size * size;\n"
"	const float scaleFactor = 1.f / sampleCount;\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"	float indirectShadowMask = 0.f;\n"
"#endif\n"
"	const bool passThroughPath = sampleResult->passThroughPath;\n"
"	for (uint currentBSDFSampleIndex = 0; currentBSDFSampleIndex < sampleCount; ++currentBSDFSampleIndex) {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"		sampleResult->indirectShadowMask = 1.f;\n"
"#endif\n"
"		sampleResult->passThroughPath = passThroughPath;\n"
"\n"
"		float u0, u1;\n"
"		SampleGrid(seed, size,\n"
"			currentBSDFSampleIndex % size, currentBSDFSampleIndex / size,\n"
"			&u0, &u1);\n"
"\n"
"		// Sample the BSDF on the first path vertex\n"
"		float3 sampledDir;\n"
"		float pdfW, cosSampledDir;\n"
"		BSDFEvent event;\n"
"		float3 bsdfSample;\n"
"\n"
"		if (BSDF_IsShadowCatcher(bsdfPathVertex1 MATERIALS_PARAM) && (1.f - lightsVisibility <= Rnd_FloatValue(seed))) {\n"
"			bsdfSample = BSDF_ShadowCatcherSample(bsdfPathVertex1,\n"
"					&sampledDir, &pdfW, &cosSampledDir, &event\n"
"					MATERIALS_PARAM);\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_ALPHA)\n"
"			// In this case I have also to set the value of the alpha channel to 0.0\n"
"			sampleResult->alpha = 0.f;\n"
"#endif\n"
"		} else {\n"
"			bsdfSample = BSDF_Sample(bsdfPathVertex1,\n"
"					u0,\n"
"					u1,\n"
"					&sampledDir, &pdfW, &cosSampledDir, &event,\n"
"					requestedEventTypes | REFLECT | TRANSMIT\n"
"					MATERIALS_PARAM);\n"
"			sampleResult->passThroughPath = false;\n"
"		}\n"
"\n"
"		if (!Spectrum_IsBlack(bsdfSample)) {\n"
"			PathDepthInfo depthInfo;\n"
"			PathDepthInfo_Init(&depthInfo);\n"
"			PathDepthInfo_IncDepths(&depthInfo, event);\n"
"\n"
"			// Update information about the first path BSDF \n"
"			sampleResult->firstPathVertexEvent = event;\n"
"\n"
"			// Update volume information\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"			// I need to work on a copy of volume information of the first path vertex\n"
"			*volInfoPathVertexN = *volInfoPathVertex1;\n"
"			PathVolumeInfo_Update(volInfoPathVertexN, event, bsdfPathVertexN\n"
"					MATERIALS_PARAM);\n"
"#endif\n"
"\n"
"			// Continue to trace the path\n"
"			const float pdfFactor = scaleFactor * ((event & SPECULAR) ? 1.f : min(1.f, pdfW / PARAM_PDF_CLAMP_VALUE));\n"
"			const float3 continuePathThroughput = throughputPathVertex1 * bsdfSample * pdfFactor;\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"			// This is valid for irradiance AOV only if it is not a SPECULAR material and\n"
"			// first path vertex. Set or update sampleResult.irradiancePathThroughput\n"
"			if (!(BSDF_GetEventTypes(bsdfPathVertex1\n"
"						MATERIALS_PARAM) & SPECULAR))\n"
"				VSTORE3F(M_1_PI_F * fabs(dot(\n"
"							VLOAD3F(&bsdfPathVertex1->hitPoint.shadeN.x),\n"
"							sampledDir)),\n"
"						sampleResult->irradiancePathThroughput.c);\n"
"			else\n"
"				VSTORE3F(BLACK, sampleResult->irradiancePathThroughput.c);\n"
"#endif\n"
"\n"
"			Ray continueRay;\n"
"			Ray_Init2_Private(&continueRay, VLOAD3F(&bsdfPathVertex1->hitPoint.p.x), sampledDir, time);\n"
"\n"
"			tracedRaysCount += ContinueTracePath(\n"
"					seed,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"					volInfoPathVertexN,\n"
"					directLightVolInfo,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0) || defined(PARAM_HAS_VOLUMES)\n"
"					tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"					worldCenterX, worldCenterY, worldCenterZ, worldRadius,\n"
"#endif\n"
"					&depthInfo, &continueRay,\n"
"					time,\n"
"					continuePathThroughput,\n"
"					event, pdfW,\n"
"					bsdfPathVertexN, directLightBSDF,\n"
"					sampleResult,\n"
"					// BSDF_Init parameters\n"
"					meshDescs,\n"
"					sceneObjs,\n"
"					vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"					vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"					vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"					vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"					vertAlphas,\n"
"#endif\n"
"					triangles\n"
"					// Accelerator_Intersect parameters\n"
"					ACCELERATOR_INTERSECT_PARAM\n"
"					// Light related parameters\n"
"					LIGHTS_PARAM);\n"
"		}\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"		// sampleResult->indirectShadowMask requires special handling: the\n"
"		// end result must be the average of all path results\n"
"		indirectShadowMask += scaleFactor * sampleResult->indirectShadowMask;\n"
"#endif\n"
"	}\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"	sampleResult->indirectShadowMask = indirectShadowMask;\n"
"#endif\n"
"\n"
"	return tracedRaysCount;\n"
"}\n"
; } }
