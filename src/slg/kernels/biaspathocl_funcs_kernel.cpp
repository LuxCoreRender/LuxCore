#include <string>
namespace slg { namespace ocl {
std::string KernelSource_biaspathocl_funcs = 
"#line 2 \"biaspatchocl_funcs.cl\"\n"
"\n"
"/***************************************************************************\n"
" * Copyright 1998-2015 by authors (see AUTHORS.txt)                        *\n"
" *                                                                         *\n"
" *   This file is part of LuxRender.                                       *\n"
" *                                                                         *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");         *\n"
" * you may not use this file except in compliance with the License.        *\n"
" * You may obtain a copy of the License at                                 *\n"
" *                                                                         *\n"
" *     http://www.apache.org/licenses/LICENSE-2.0                          *\n"
" *                                                                         *\n"
" * Unless required by applicable law or agreed to in writing, software     *\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,       *\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*\n"
" * See the License for the specific language governing permissions and     *\n"
" * limitations under the License.                                          *\n"
" ***************************************************************************/\n"
"\n"
"void SR_Accumulate(__global SampleResult *src, SampleResult *dst) {\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_0)\n"
"	dst->radiancePerPixelNormalized[0].c[0] += src->radiancePerPixelNormalized[0].c[0];\n"
"	dst->radiancePerPixelNormalized[0].c[1] += src->radiancePerPixelNormalized[0].c[1];\n"
"	dst->radiancePerPixelNormalized[0].c[2] += src->radiancePerPixelNormalized[0].c[2];\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_1)\n"
"	dst->radiancePerPixelNormalized[1].c[0] += src->radiancePerPixelNormalized[1].c[0];\n"
"	dst->radiancePerPixelNormalized[1].c[1] += src->radiancePerPixelNormalized[1].c[1];\n"
"	dst->radiancePerPixelNormalized[1].c[2] += src->radiancePerPixelNormalized[1].c[2];\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_2)\n"
"	dst->radiancePerPixelNormalized[2].c[0] += src->radiancePerPixelNormalized[2].c[0];\n"
"	dst->radiancePerPixelNormalized[2].c[1] += src->radiancePerPixelNormalized[2].c[1];\n"
"	dst->radiancePerPixelNormalized[2].c[2] += src->radiancePerPixelNormalized[2].c[2];\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_3)\n"
"	dst->radiancePerPixelNormalized[3].c[0] += src->radiancePerPixelNormalized[3].c[0];\n"
"	dst->radiancePerPixelNormalized[3].c[1] += src->radiancePerPixelNormalized[3].c[1];\n"
"	dst->radiancePerPixelNormalized[3].c[2] += src->radiancePerPixelNormalized[3].c[2];\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_4)\n"
"	dst->radiancePerPixelNormalized[4].c[0] += src->radiancePerPixelNormalized[4].c[0];\n"
"	dst->radiancePerPixelNormalized[4].c[1] += src->radiancePerPixelNormalized[4].c[1];\n"
"	dst->radiancePerPixelNormalized[4].c[2] += src->radiancePerPixelNormalized[4].c[2];\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_5)\n"
"	dst->radiancePerPixelNormalized[5].c[0] += src->radiancePerPixelNormalized[5].c[0];\n"
"	dst->radiancePerPixelNormalized[5].c[1] += src->radiancePerPixelNormalized[5].c[1];\n"
"	dst->radiancePerPixelNormalized[5].c[2] += src->radiancePerPixelNormalized[5].c[2];\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_6)\n"
"	dst->radiancePerPixelNormalized[6].c[0] += src->radiancePerPixelNormalized[6].c[0];\n"
"	dst->radiancePerPixelNormalized[6].c[1] += src->radiancePerPixelNormalized[6].c[1];\n"
"	dst->radiancePerPixelNormalized[6].c[2] += src->radiancePerPixelNormalized[6].c[2];\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_7)\n"
"	dst->radiancePerPixelNormalized[7].c[0] += src->radiancePerPixelNormalized[7].c[0];\n"
"	dst->radiancePerPixelNormalized[7].c[1] += src->radiancePerPixelNormalized[7].c[1];\n"
"	dst->radiancePerPixelNormalized[7].c[2] += src->radiancePerPixelNormalized[7].c[2];\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_ALPHA)\n"
"	dst->alpha += dst->alpha + src->alpha;\n"
"#endif\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_DIFFUSE)\n"
"	dst->directDiffuse.c[0] += src->directDiffuse.c[0];\n"
"	dst->directDiffuse.c[1] += src->directDiffuse.c[1];\n"
"	dst->directDiffuse.c[2] += src->directDiffuse.c[2];\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_GLOSSY)\n"
"	dst->directGlossy.c[0] += src->directGlossy.c[0];\n"
"	dst->directGlossy.c[1] += src->directGlossy.c[1];\n"
"	dst->directGlossy.c[2] += src->directGlossy.c[2];\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_EMISSION)\n"
"	dst->emission.c[0] += src->emission.c[0];\n"
"	dst->emission.c[1] += src->emission.c[1];\n"
"	dst->emission.c[2] += src->emission.c[2];\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_DIFFUSE)\n"
"	dst->indirectDiffuse.c[0] += src->indirectDiffuse.c[0];\n"
"	dst->indirectDiffuse.c[1] += src->indirectDiffuse.c[1];\n"
"	dst->indirectDiffuse.c[2] += src->indirectDiffuse.c[2];\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_GLOSSY)\n"
"	dst->indirectGlossy.c[0] += src->indirectGlossy.c[0];\n"
"	dst->indirectGlossy.c[1] += src->indirectGlossy.c[1];\n"
"	dst->indirectGlossy.c[2] += src->indirectGlossy.c[2];\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SPECULAR)\n"
"	dst->indirectSpecular.c[0] += src->indirectSpecular.c[0];\n"
"	dst->indirectSpecular.c[1] += src->indirectSpecular.c[1];\n"
"	dst->indirectSpecular.c[2] += src->indirectSpecular.c[2];\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_SHADOW_MASK)\n"
"	dst->directShadowMask += src->directShadowMask;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"	dst->indirectShadowMask += src->indirectShadowMask;\n"
"#endif\n"
"\n"
"	bool depthWrite = true;\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DEPTH)\n"
"	const float srcDepthValue = src->depth;\n"
"	if (srcDepthValue <= dst->depth)\n"
"		dst->depth = srcDepthValue;\n"
"	else\n"
"		depthWrite = false;\n"
"#endif\n"
"	if (depthWrite) {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_POSITION)\n"
"		dst->position = src->position;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_GEOMETRY_NORMAL)\n"
"		dst->geometryNormal = src->geometryNormal;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_SHADING_NORMAL)\n"
"		dst->shadingNormal = src->shadingNormal;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_MATERIAL_ID)\n"
"		// Note: MATERIAL_ID_MASK and BY_MATERIAL_ID are calculated starting from materialID field\n"
"		dst->materialID = src->materialID;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_UV)\n"
"		dst->uv = src->uv;\n"
"#endif\n"
"	}\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_RAYCOUNT)\n"
"	dst->rayCount += src->rayCount;\n"
"#endif\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"	dst->irradiance.c[0] += src->irradiance.c[0];\n"
"	dst->irradiance.c[1] += src->irradiance.c[1];\n"
"	dst->irradiance.c[2] += src->irradiance.c[2];\n"
"#endif\n"
"}\n"
"\n"
"void SR_Normalize(SampleResult *dst, const float k) {\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_0)\n"
"	dst->radiancePerPixelNormalized[0].c[0] *= k;\n"
"	dst->radiancePerPixelNormalized[0].c[1] *= k;\n"
"	dst->radiancePerPixelNormalized[0].c[2] *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_1)\n"
"	dst->radiancePerPixelNormalized[1].c[0] *= k;\n"
"	dst->radiancePerPixelNormalized[1].c[1] *= k;\n"
"	dst->radiancePerPixelNormalized[1].c[2] *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_2)\n"
"	dst->radiancePerPixelNormalized[2].c[0] *= k;\n"
"	dst->radiancePerPixelNormalized[2].c[1] *= k;\n"
"	dst->radiancePerPixelNormalized[2].c[2] *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_3)\n"
"	dst->radiancePerPixelNormalized[3].c[0] *= k;\n"
"	dst->radiancePerPixelNormalized[3].c[1] *= k;\n"
"	dst->radiancePerPixelNormalized[3].c[2] *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_4)\n"
"	dst->radiancePerPixelNormalized[4].c[0] *= k;\n"
"	dst->radiancePerPixelNormalized[4].c[1] *= k;\n"
"	dst->radiancePerPixelNormalized[4].c[2] *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_5)\n"
"	dst->radiancePerPixelNormalized[5].c[0] *= k;\n"
"	dst->radiancePerPixelNormalized[5].c[1] *= k;\n"
"	dst->radiancePerPixelNormalized[5].c[2] *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_6)\n"
"	dst->radiancePerPixelNormalized[6].c[0] *= k;\n"
"	dst->radiancePerPixelNormalized[6].c[1] *= k;\n"
"	dst->radiancePerPixelNormalized[6].c[2] *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_7)\n"
"	dst->radiancePerPixelNormalized[7].c[0] *= k;\n"
"	dst->radiancePerPixelNormalized[7].c[1] *= k;\n"
"	dst->radiancePerPixelNormalized[7].c[2] *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_ALPHA)\n"
"	dst->alpha *= k;\n"
"#endif\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_DIFFUSE)\n"
"	dst->directDiffuse.c[0] *= k;\n"
"	dst->directDiffuse.c[1] *= k;\n"
"	dst->directDiffuse.c[2] *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_GLOSSY)\n"
"	dst->directGlossy.c[0] *= k;\n"
"	dst->directGlossy.c[1] *= k;\n"
"	dst->directGlossy.c[2] *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_EMISSION)\n"
"	dst->emission.c[0] *= k;\n"
"	dst->emission.c[1] *= k;\n"
"	dst->emission.c[2] *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_DIFFUSE)\n"
"	dst->indirectDiffuse.c[0] *= k;\n"
"	dst->indirectDiffuse.c[1] *= k;\n"
"	dst->indirectDiffuse.c[2] *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_GLOSSY)\n"
"	dst->indirectGlossy.c[0] *= k;\n"
"	dst->indirectGlossy.c[1] *= k;\n"
"	dst->indirectGlossy.c[2] *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SPECULAR)\n"
"	dst->indirectSpecular.c[0] *= k;\n"
"	dst->indirectSpecular.c[1] *= k;\n"
"	dst->indirectSpecular.c[2] *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_SHADOW_MASK)\n"
"	dst->directShadowMask *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"	dst->indirectShadowMask *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"	dst->irradiance.c[0] *= k;\n"
"	dst->irradiance.c[1] *= k;\n"
"	dst->irradiance.c[2] *= k;\n"
"#endif\n"
"}\n"
"\n"
"void SampleGrid(Seed *seed, const uint size,\n"
"		const uint ix, const uint iy, float *u0, float *u1) {\n"
"	*u0 = Rnd_FloatValue(seed);\n"
"	*u1 = Rnd_FloatValue(seed);\n"
"\n"
"	if (size > 1) {\n"
"		const float idim = 1.f / size;\n"
"		*u0 = (ix + *u0) * idim;\n"
"		*u1 = (iy + *u1) * idim;\n"
"	}\n"
"}\n"
"\n"
"typedef struct {\n"
"	uint depth, diffuseDepth, glossyDepth, specularDepth;\n"
"} PathDepthInfo;\n"
"\n"
"void PathDepthInfo_Init(PathDepthInfo *depthInfo) {\n"
"	depthInfo->depth = 0;\n"
"	depthInfo->diffuseDepth = 0;\n"
"	depthInfo->glossyDepth = 0;\n"
"	depthInfo->specularDepth = 0;\n"
"}\n"
"\n"
"void PathDepthInfo_IncDepths(PathDepthInfo *depthInfo, const BSDFEvent event) {\n"
"	++(depthInfo->depth);\n"
"	if (event & DIFFUSE)\n"
"		++(depthInfo->diffuseDepth);\n"
"	if (event & GLOSSY)\n"
"		++(depthInfo->glossyDepth);\n"
"	if (event & SPECULAR)\n"
"		++(depthInfo->specularDepth);\n"
"}\n"
"\n"
"bool PathDepthInfo_IsLastPathVertex(const PathDepthInfo *depthInfo, const BSDFEvent event) {\n"
"	return (depthInfo->depth + 1 == PARAM_DEPTH_MAX) ||\n"
"			((event & DIFFUSE) && (depthInfo->diffuseDepth + 1 == PARAM_DEPTH_DIFFUSE_MAX)) ||\n"
"			((event & GLOSSY) && (depthInfo->glossyDepth + 1 == PARAM_DEPTH_GLOSSY_MAX)) ||\n"
"			((event & SPECULAR) && (depthInfo->specularDepth + 1 == PARAM_DEPTH_SPECULAR_MAX));\n"
"}\n"
"\n"
"bool PathDepthInfo_CheckComponentDepths(const BSDFEvent component) {\n"
"	return ((component & DIFFUSE) && (PARAM_DEPTH_DIFFUSE_MAX > 0)) ||\n"
"			((component & GLOSSY) && (PARAM_DEPTH_GLOSSY_MAX > 0)) ||\n"
"			((component & SPECULAR) && (PARAM_DEPTH_SPECULAR_MAX > 0));\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"void GenerateCameraRay(\n"
"		Seed *seed,\n"
"		__global GPUTask *task,\n"
"		__global SampleResult *sampleResult,\n"
"		__global const Camera* restrict camera,\n"
"		__global float *pixelFilterDistribution,\n"
"		const uint sampleX, const uint sampleY, const int sampleIndex,\n"
"		const uint tileStartX, const uint tileStartY, \n"
"		const uint engineFilmWidth, const uint engineFilmHeight,\n"
"		Ray *ray) {\n"
"	//if (get_global_id(0) == 0)\n"
"	//	printf(\"tileSampleIndex: %d (%d, %d)\\n\", sampleIndex, sampleIndex % PARAM_AA_SAMPLES, sampleIndex / PARAM_AA_SAMPLES);\n"
"\n"
"	float u0, u1;\n"
"	SampleGrid(seed, PARAM_AA_SAMPLES,\n"
"			sampleIndex % PARAM_AA_SAMPLES, sampleIndex / PARAM_AA_SAMPLES,\n"
"			&u0, &u1);\n"
"\n"
"	// Sample according the pixel filter distribution\n"
"	FilterDistribution_SampleContinuous(pixelFilterDistribution, u0, u1, &u0, &u1);\n"
"\n"
"	const float filmX = sampleX + .5f + u0;\n"
"	const float filmY = sampleY + .5f + u1;\n"
"	sampleResult->filmX = filmX;\n"
"	sampleResult->filmY = filmY;\n"
"\n"
"#if defined(PARAM_CAMERA_HAS_DOF)\n"
"	const float dofSampleX = Rnd_FloatValue(seed);\n"
"	const float dofSampleY = Rnd_FloatValue(seed);\n"
"#endif\n"
"\n"
"	Camera_GenerateRay(camera, engineFilmWidth, engineFilmHeight, ray,\n"
"			tileStartX + filmX, tileStartY + filmY, Rnd_FloatValue(seed)\n"
"#if defined(PARAM_CAMERA_HAS_DOF)\n"
"			, dofSampleX, dofSampleY\n"
"#endif\n"
"			);	\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"uint BIASPATHOCL_Scene_Intersect(\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		__global PathVolumeInfo *volInfo,\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		const float initialPassThrough,\n"
"#endif\n"
"#if !defined(RENDER_ENGINE_BIASPATHOCL) && !defined(RENDER_ENGINE_RTBIASPATHOCL)\n"
"		__global\n"
"#endif\n"
"		Ray *ray,\n"
"#if !defined(RENDER_ENGINE_BIASPATHOCL) && !defined(RENDER_ENGINE_RTBIASPATHOCL)\n"
"		__global\n"
"#endif\n"
"		RayHit *rayHit,\n"
"		__global BSDF *bsdf,\n"
"		float3 *connectionThroughput,  const float3 pathThroughput,\n"
"		__global SampleResult *sampleResult,\n"
"		// BSDF_Init parameters\n"
"		__global const Mesh* restrict meshDescs,\n"
"		__global const uint* restrict meshMats,\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		__global const uint *meshTriLightDefsOffset,\n"
"#endif\n"
"		__global const Point* restrict vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"		__global const Vector *vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"		__global const UV* restrict vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"		__global const Spectrum* restrict vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"		__global const float* restrict vertAlphas,\n"
"#endif\n"
"		__global const Triangle* restrict triangles\n"
"		MATERIALS_PARAM_DECL\n"
"		// Accelerator_Intersect parameters\n"
"		ACCELERATOR_INTERSECT_PARAM_DECL\n"
"		) {\n"
"	*connectionThroughput = WHITE;\n"
"	uint tracedRaysCount = 0;\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"	float passThrough = initialPassThrough;\n"
"#endif\n"
"\n"
"	for (;;) {\n"
"		Accelerator_Intersect(ray, rayHit\n"
"			ACCELERATOR_INTERSECT_PARAM);\n"
"		++tracedRaysCount;\n"
"\n"
"		float3 connectionSegmentThroughput;\n"
"		const bool continueToTrace = Scene_Intersect(\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"			volInfo,\n"
"			tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"			passThrough,\n"
"#endif\n"
"			ray, rayHit, bsdf,\n"
"			&connectionSegmentThroughput, pathThroughput * (*connectionThroughput),\n"
"			sampleResult,\n"
"			// BSDF_Init parameters\n"
"			meshDescs,\n"
"			meshMats,\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"			meshTriLightDefsOffset,\n"
"#endif\n"
"			vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"			vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"			vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"			vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"			vertAlphas,\n"
"#endif\n"
"			triangles\n"
"			MATERIALS_PARAM\n"
"			);\n"
"		*connectionThroughput *= connectionSegmentThroughput;\n"
"		if (!continueToTrace)\n"
"			break;\n"
"\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		// I generate a new random variable starting from the previous one. I'm\n"
"		// not really sure about the kind of correlation introduced by this\n"
"		// trick.\n"
"		passThrough = fabs(passThrough - .5f) * 2.f;\n"
"#endif\n"
"	}\n"
"	\n"
"	return tracedRaysCount;\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Direct hit  on lights\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"void DirectHitFiniteLight(\n"
"		const BSDFEvent lastBSDFEvent,\n"
"		const float3 pathThroughput, const float distance, __global BSDF *bsdf,\n"
"		const float lastPdfW, __global SampleResult *sampleResult\n"
"		LIGHTS_PARAM_DECL) {\n"
"	if (sampleResult->firstPathVertex ||\n"
"			(lights[bsdf->triangleLightSourceIndex].visibility &\n"
"			(sampleResult->firstPathVertexEvent & (DIFFUSE | GLOSSY | SPECULAR)))) {\n"
"		float directPdfA;\n"
"		const float3 emittedRadiance = BSDF_GetEmittedRadiance(bsdf, &directPdfA\n"
"				LIGHTS_PARAM);\n"
"\n"
"		if (!Spectrum_IsBlack(emittedRadiance)) {\n"
"			// Add emitted radiance\n"
"			float weight = 1.f;\n"
"			if (!(lastBSDFEvent & SPECULAR)) {\n"
"				const float lightPickProb = Scene_SampleAllLightPdf(lightsDistribution,\n"
"						lights[bsdf->triangleLightSourceIndex].lightSceneIndex);\n"
"				const float directPdfW = PdfAtoW(directPdfA, distance,\n"
"					fabs(dot(VLOAD3F(&bsdf->hitPoint.fixedDir.x), VLOAD3F(&bsdf->hitPoint.shadeN.x))));\n"
"\n"
"				// MIS between BSDF sampling and direct light sampling\n"
"				weight = PowerHeuristic(lastPdfW, directPdfW * lightPickProb);\n"
"			}\n"
"\n"
"			SampleResult_AddEmission(sampleResult, BSDF_GetLightID(bsdf\n"
"					MATERIALS_PARAM), pathThroughput, weight * emittedRadiance);\n"
"		}\n"
"	}\n"
"}\n"
"#endif\n"
"\n"
"#if defined(PARAM_HAS_ENVLIGHTS)\n"
"void DirectHitInfiniteLight(\n"
"		const BSDFEvent lastBSDFEvent,\n"
"		const float3 pathThroughput,\n"
"		const float3 eyeDir, const float lastPdfW,\n"
"		__global SampleResult *sampleResult\n"
"		LIGHTS_PARAM_DECL) {\n"
"	for (uint i = 0; i < envLightCount; ++i) {\n"
"		__global const LightSource* restrict light = &lights[envLightIndices[i]];\n"
"\n"
"		if (sampleResult->firstPathVertex || (light->visibility & (sampleResult->firstPathVertexEvent & (DIFFUSE | GLOSSY | SPECULAR)))) {\n"
"			float directPdfW;\n"
"			const float3 envRadiance = EnvLight_GetRadiance(light, eyeDir, &directPdfW\n"
"					LIGHTS_PARAM);\n"
"\n"
"			if (!Spectrum_IsBlack(envRadiance)) {\n"
"				// MIS between BSDF sampling and direct light sampling\n"
"				const float lightPickProb = Scene_SampleAllLightPdf(lightsDistribution, light->lightSceneIndex);\n"
"				const float weight = ((lastBSDFEvent & SPECULAR) ? 1.f : PowerHeuristic(lastPdfW, directPdfW * lightPickProb));\n"
"\n"
"				SampleResult_AddEmission(sampleResult, light->lightID, pathThroughput, weight * envRadiance);\n"
"			}\n"
"		}\n"
"	}\n"
"}\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Direct light sampling\n"
"//------------------------------------------------------------------------------\n"
"\n"
"bool DirectLightSamplingInit(\n"
"		__global const LightSource* restrict light,\n"
"		const float lightPickPdf,\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"		const float time, const float u0, const float u1,\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		const float passThroughEvent,\n"
"#endif\n"
"		__global BSDF *bsdf, BSDFEvent *event,\n"
"		__global SampleResult *sampleResult,\n"
"		Ray *shadowRay,\n"
"		float3 *radiance,\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"		float3 *irradiance,\n"
"#endif\n"
"		uint *ID\n"
"		LIGHTS_PARAM_DECL) {\n"
"	float3 lightRayDir;\n"
"	float distance, directPdfW;\n"
"	const float3 lightRadiance = Light_Illuminate(\n"
"			light,\n"
"			VLOAD3F(&bsdf->hitPoint.p.x),\n"
"			u0, u1,\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"			passThroughEvent,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"			worldCenterX, worldCenterY, worldCenterZ, worldRadius,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"			tmpHitPoint,\n"
"#endif		\n"
"			&lightRayDir, &distance, &directPdfW\n"
"			LIGHTS_PARAM);\n"
"\n"
"	// Setup the shadow ray\n"
"	const float cosThetaToLight = fabs(dot(lightRayDir, VLOAD3F(&bsdf->hitPoint.shadeN.x)));\n"
"	if (((Spectrum_Y(lightRadiance) * cosThetaToLight / directPdfW) > PARAM_LOW_LIGHT_THREASHOLD) &&\n"
"			(distance > PARAM_NEAR_START_LIGHT)) {\n"
"		float bsdfPdfW;\n"
"		const float3 bsdfEval = BSDF_Evaluate(bsdf,\n"
"				lightRayDir, event, &bsdfPdfW\n"
"				MATERIALS_PARAM);\n"
"\n"
"		if (!Spectrum_IsBlack(bsdfEval)) {\n"
"			const float directLightSamplingPdfW = directPdfW * lightPickPdf;\n"
"			const float factor = 1.f / directLightSamplingPdfW;\n"
"\n"
"			// MIS between direct light sampling and BSDF sampling\n"
"			const float weight = (!sampleResult->lastPathVertex && Light_IsEnvOrIntersectable(light)) ?\n"
"				PowerHeuristic(directLightSamplingPdfW, bsdfPdfW) : 1.f;\n"
"\n"
"			*radiance = bsdfEval * (weight * factor) * lightRadiance;\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"			*irradiance = factor * lightRadiance;\n"
"#endif\n"
"			*ID = light->lightID;\n"
"\n"
"			// Setup the shadow ray\n"
"			const float3 hitPoint = VLOAD3F(&bsdf->hitPoint.p.x);\n"
"			const float epsilon = fmax(MachineEpsilon_E_Float3(hitPoint), MachineEpsilon_E(distance));\n"
"\n"
"			Ray_Init4_Private(shadowRay, hitPoint, lightRayDir,\n"
"				epsilon,\n"
"				distance - epsilon, time);\n"
"\n"
"			return true;\n"
"		}\n"
"	}\n"
"\n"
"	return false;\n"
"}\n"
"\n"
"uint DirectLightSampling_ONE(\n"
"		Seed *seed,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		__global PathVolumeInfo *volInfo,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0) || defined(PARAM_HAS_VOLUMES)\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"		const float time,\n"
"		const float3 pathThroughput,\n"
"		__global BSDF *bsdf, __global BSDF *directLightBSDF,\n"
"		__global SampleResult *sampleResult,\n"
"		// BSDF_Init parameters\n"
"		__global const Mesh* restrict meshDescs,\n"
"		__global const uint* restrict meshMats,\n"
"		__global const Point* restrict vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"		__global const Vector* restrict vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"		__global const UV* restrict vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"		__global const Spectrum* restrict vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"		__global const float* restrict vertAlphas,\n"
"#endif\n"
"		__global const Triangle* restrict triangles\n"
"		// Accelerator_Intersect parameters\n"
"		ACCELERATOR_INTERSECT_PARAM_DECL\n"
"		// Light related parameters\n"
"		LIGHTS_PARAM_DECL) {\n"
"	// ONE direct light sampling strategy\n"
"\n"
"	// Pick a light source to sample\n"
"	float lightPickPdf;\n"
"	const uint lightIndex = Scene_SampleAllLights(lightsDistribution, Rnd_FloatValue(seed), &lightPickPdf);\n"
"\n"
"	Ray shadowRay;\n"
"	uint lightID;\n"
"	BSDFEvent event;\n"
"	float3 lightRadiance;\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"	float3 lightIrradiance;\n"
"#endif\n"
"	const bool illuminated = DirectLightSamplingInit(\n"
"		&lights[lightIndex],\n"
"		lightPickPdf,\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"		worldCenterX,\n"
"		worldCenterY,\n"
"		worldCenterZ,\n"
"		worldRadius,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		tmpHitPoint,\n"
"#endif\n"
"		time, Rnd_FloatValue(seed), Rnd_FloatValue(seed),\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		Rnd_FloatValue(seed),\n"
"#endif\n"
"		bsdf, &event, sampleResult,\n"
"		&shadowRay, &lightRadiance,\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"		&lightIrradiance,\n"
"#endif\n"
"		&lightID\n"
"		LIGHTS_PARAM);\n"
"\n"
"	uint tracedRaysCount = 0;\n"
"	if (illuminated) {\n"
"		// Trace the shadow ray\n"
"\n"
"		float3 connectionThroughput;\n"
"		RayHit shadowRayHit;\n"
"		tracedRaysCount += BIASPATHOCL_Scene_Intersect(\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"				volInfo,\n"
"				tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"				Rnd_FloatValue(seed),\n"
"#endif\n"
"				&shadowRay, &shadowRayHit,\n"
"				directLightBSDF,\n"
"				&connectionThroughput, pathThroughput,\n"
"				sampleResult,\n"
"				// BSDF_Init parameters\n"
"				meshDescs,\n"
"				meshMats,\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"				meshTriLightDefsOffset,\n"
"#endif\n"
"				vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"				vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"				vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"				vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"				vertAlphas,\n"
"#endif\n"
"				triangles\n"
"				MATERIALS_PARAM\n"
"				// Accelerator_Intersect parameters\n"
"				ACCELERATOR_INTERSECT_PARAM\n"
"				);\n"
"\n"
"		if (shadowRayHit.meshIndex == NULL_INDEX) {\n"
"			// Nothing was hit, the light source is visible\n"
"			SampleResult_AddDirectLight(sampleResult, lightID, event, pathThroughput,\n"
"					connectionThroughput * lightRadiance, 1.f);\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"			// The first path vertex is not handled by AddDirectLight(). This is valid\n"
"			// for irradiance AOV only if it is not a SPECULAR material and first path vertex\n"
"			if ((sampleResult->firstPathVertex) && !(BSDF_GetEventTypes(bsdf\n"
"						MATERIALS_PARAM) & SPECULAR))\n"
"				VSTORE3F(VLOAD3F(sampleResult->irradiance.c) +\n"
"						M_1_PI_F * fabs(dot(VLOAD3F(&bsdf->hitPoint.shadeN.x),\n"
"						(float3)(shadowRay.d.x, shadowRay.d.y, shadowRay.d.z))) *\n"
"							connectionThroughput * lightIrradiance,\n"
"						sampleResult->irradiance.c);\n"
"#endif\n"
"		}\n"
"	}\n"
"	\n"
"	return tracedRaysCount;\n"
"}\n"
"\n"
"uint DirectLightSampling_ALL(\n"
"		Seed *seed,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		__global PathVolumeInfo *volInfo,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0) || defined(PARAM_HAS_VOLUMES)\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"		const float time,\n"
"		const float3 pathThroughput,\n"
"		__global BSDF *bsdf, __global BSDF *directLightBSDF,\n"
"		__global SampleResult *sampleResult,\n"
"		// BSDF_Init parameters\n"
"		__global const Mesh* restrict meshDescs,\n"
"		__global const uint* restrict meshMats,\n"
"		__global const Point* restrict vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"		__global const Vector* restrict vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"		__global const UV* restrict vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"		__global const Spectrum* restrict vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"		__global const float* restrict vertAlphas,\n"
"#endif\n"
"		__global const Triangle* restrict triangles\n"
"		// Accelerator_Intersect parameters\n"
"		ACCELERATOR_INTERSECT_PARAM_DECL\n"
"		// Light related parameters\n"
"		LIGHTS_PARAM_DECL) {\n"
"	uint tracedRaysCount = 0;\n"
"\n"
"	for (uint samples = 0; samples < PARAM_FIRST_VERTEX_DL_COUNT; ++samples) {\n"
"		// Pick a light source to sample\n"
"		float lightPickPdf;\n"
"		const uint lightIndex = Scene_SampleAllLights(lightsDistribution, Rnd_FloatValue(seed), &lightPickPdf);\n"
"\n"
"		__global const LightSource* restrict light = &lights[lightIndex];\n"
"		const int lightSamplesCount = light->samples;\n"
"		const uint sampleCount = (lightSamplesCount < 0) ? PARAM_DIRECT_LIGHT_SAMPLES : (uint)lightSamplesCount;\n"
"		const uint sampleCount2 = sampleCount * sampleCount;\n"
"\n"
"		const float scaleFactor = 1.f / (sampleCount2 * PARAM_FIRST_VERTEX_DL_COUNT);\n"
"		for (uint currentLightSampleIndex = 0; currentLightSampleIndex < sampleCount2; ++currentLightSampleIndex) {\n"
"			float u0, u1;\n"
"			SampleGrid(seed, sampleCount,\n"
"					currentLightSampleIndex % sampleCount, currentLightSampleIndex / sampleCount,\n"
"					&u0, &u1);\n"
"\n"
"			Ray shadowRay;\n"
"			float3 lightRadiance;\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"			float3 lightIrradiance;\n"
"#endif\n"
"			uint lightID;\n"
"			BSDFEvent event;\n"
"			const bool illuminated = DirectLightSamplingInit(\n"
"				light,\n"
"				lightPickPdf,\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"				worldCenterX,\n"
"				worldCenterY,\n"
"				worldCenterZ,\n"
"				worldRadius,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"				tmpHitPoint,\n"
"#endif\n"
"				time, u0, u1,\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"				Rnd_FloatValue(seed),\n"
"#endif\n"
"				bsdf, &event, sampleResult,\n"
"				&shadowRay, &lightRadiance,\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"				&lightIrradiance,\n"
"#endif\n"
"				&lightID\n"
"				LIGHTS_PARAM);\n"
"\n"
"			if (illuminated) {\n"
"				// Trace the shadow ray\n"
"\n"
"				float3 connectionThroughput;\n"
"				RayHit shadowRayHit;\n"
"				tracedRaysCount += BIASPATHOCL_Scene_Intersect(\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"						volInfo,\n"
"						tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"						Rnd_FloatValue(seed),\n"
"#endif\n"
"						&shadowRay, &shadowRayHit,\n"
"						directLightBSDF,\n"
"						&connectionThroughput, pathThroughput,\n"
"						sampleResult,\n"
"						// BSDF_Init parameters\n"
"						meshDescs,\n"
"						meshMats,\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"						meshTriLightDefsOffset,\n"
"#endif\n"
"						vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"						vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"						vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"						vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"						vertAlphas,\n"
"#endif\n"
"						triangles\n"
"						MATERIALS_PARAM\n"
"						// Accelerator_Intersect parameters\n"
"						ACCELERATOR_INTERSECT_PARAM\n"
"						);\n"
"\n"
"				if (shadowRayHit.meshIndex == NULL_INDEX) {\n"
"					// Nothing was hit, the light source is visible\n"
"					const float3 incomingRadiance = scaleFactor * connectionThroughput * lightRadiance;\n"
"					SampleResult_AddDirectLight(sampleResult, lightID, event,\n"
"							pathThroughput, incomingRadiance, scaleFactor);\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"					// The first path vertex is not handled by AddDirectLight(). This is valid\n"
"					// for irradiance AOV only if it is not a SPECULAR material and first path vertex\n"
"					if ((sampleResult->firstPathVertex) && !(BSDF_GetEventTypes(bsdf\n"
"								MATERIALS_PARAM) & SPECULAR))\n"
"						VSTORE3F(VLOAD3F(sampleResult->irradiance.c) +\n"
"								(M_1_PI_F * fabs(dot(VLOAD3F(&bsdf->hitPoint.shadeN.x),\n"
"								(float3)(shadowRay.d.x, shadowRay.d.y, shadowRay.d.z))) * scaleFactor) *\n"
"									connectionThroughput * lightIrradiance,\n"
"								sampleResult->irradiance.c);\n"
"#endif\n"
"				}\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"	return tracedRaysCount;\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Indirect light sampling\n"
"//------------------------------------------------------------------------------\n"
"\n"
"uint ContinueTracePath(\n"
"		Seed *seed,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		__global PathVolumeInfo *volInfoPathVertexN,\n"
"		__global PathVolumeInfo *directLightVolInfo,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0) || defined(PARAM_HAS_VOLUMES)\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"		PathDepthInfo *depthInfo,\n"
"		Ray *ray,\n"
"		const float time,\n"
"		float3 pathThroughput,\n"
"		BSDFEvent lastBSDFEvent, float lastPdfW,\n"
"		__global BSDF *bsdfPathVertexN, __global BSDF *directLightBSDF,\n"
"		__global SampleResult *sampleResult,\n"
"		// BSDF_Init parameters\n"
"		__global const Mesh* restrict meshDescs,\n"
"		__global const uint* restrict meshMats,\n"
"		__global const Point* restrict vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"		__global const Vector* restrict vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"		__global const UV* restrict vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"		__global const Spectrum* restrict vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"		__global const float* restrict vertAlphas,\n"
"#endif\n"
"		__global const Triangle* restrict triangles\n"
"		// Accelerator_Intersect parameters\n"
"		ACCELERATOR_INTERSECT_PARAM_DECL\n"
"		// Light related parameters\n"
"		LIGHTS_PARAM_DECL) {\n"
"	uint tracedRaysCount = 0;\n"
"\n"
"	for (;;) {\n"
"		//----------------------------------------------------------------------\n"
"		// Trace the ray\n"
"		//----------------------------------------------------------------------\n"
"\n"
"		float3 connectionThroughput;\n"
"		RayHit rayHit;\n"
"		tracedRaysCount += BIASPATHOCL_Scene_Intersect(\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"			volInfoPathVertexN,\n"
"			tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"			Rnd_FloatValue(seed),\n"
"#endif\n"
"			ray, &rayHit,\n"
"			bsdfPathVertexN,\n"
"			&connectionThroughput, pathThroughput,\n"
"			sampleResult,\n"
"			// BSDF_Init parameters\n"
"			meshDescs,\n"
"			meshMats,\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"			meshTriLightDefsOffset,\n"
"#endif\n"
"			vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"			vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"			vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"			vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"			vertAlphas,\n"
"#endif\n"
"			triangles\n"
"			MATERIALS_PARAM\n"
"			// Accelerator_Intersect parameters\n"
"			ACCELERATOR_INTERSECT_PARAM);\n"
"		pathThroughput *= connectionThroughput;\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"		// Update also irradiance AOV path throughput\n"
"		VSTORE3F(VLOAD3F(sampleResult->irradiancePathThroughput.c) * connectionThroughput, sampleResult->irradiancePathThroughput.c);\n"
"#endif\n"
"\n"
"		if (rayHit.meshIndex == NULL_INDEX) {\n"
"			// Nothing was hit, look for env. lights\n"
"\n"
"#if defined(PARAM_HAS_ENVLIGHTS)\n"
"			// Add environmental lights radiance\n"
"			const float3 rayDir = (float3)(ray->d.x, ray->d.y, ray->d.z);\n"
"			DirectHitInfiniteLight(\n"
"					lastBSDFEvent,\n"
"					pathThroughput,\n"
"					-rayDir, lastPdfW,\n"
"					sampleResult\n"
"					LIGHTS_PARAM);\n"
"#endif\n"
"\n"
"			break;\n"
"		}\n"
"\n"
"		// Something was hit\n"
"\n"
"		// Check if it is visible in indirect paths\n"
"		if (!(mats[bsdfPathVertexN->materialIndex].visibility &\n"
"				(sampleResult->firstPathVertexEvent & (DIFFUSE | GLOSSY | SPECULAR))))\n"
"			break;\n"
"\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		// Check if it is a light source (note: I can hit only triangle area light sources)\n"
"		if (BSDF_IsLightSource(bsdfPathVertexN) && (rayHit.t > PARAM_NEAR_START_LIGHT)) {\n"
"			DirectHitFiniteLight(lastBSDFEvent,\n"
"					pathThroughput,\n"
"					rayHit.t, bsdfPathVertexN, lastPdfW,\n"
"					sampleResult\n"
"					LIGHTS_PARAM);\n"
"		}\n"
"#endif\n"
"\n"
"		//------------------------------------------------------------------\n"
"		// Direct light sampling\n"
"		//------------------------------------------------------------------\n"
"\n"
"		// I avoid to do DL on the last vertex otherwise it introduces a lot of\n"
"		// noise because I can not use MIS\n"
"		sampleResult->lastPathVertex = PathDepthInfo_IsLastPathVertex(depthInfo,\n"
"				BSDF_GetEventTypes(bsdfPathVertexN\n"
"					MATERIALS_PARAM));\n"
"		if (sampleResult->lastPathVertex)\n"
"			break;\n"
"\n"
"		// Only if it is not a SPECULAR BSDF\n"
"		if (!BSDF_IsDelta(bsdfPathVertexN\n"
"				MATERIALS_PARAM)) {\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"			// I need to work on a copy of volume information of the path vertex\n"
"			*directLightVolInfo = *volInfoPathVertexN;\n"
"#endif\n"
"\n"
"			tracedRaysCount += DirectLightSampling_ONE(\n"
"				seed,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"				directLightVolInfo,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0) || defined(PARAM_HAS_VOLUMES)\n"
"				tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"				worldCenterX, worldCenterY, worldCenterZ, worldRadius,\n"
"#endif\n"
"				time,\n"
"				pathThroughput,\n"
"				bsdfPathVertexN, directLightBSDF,\n"
"				sampleResult,\n"
"				// BSDF_Init parameters\n"
"				meshDescs,\n"
"				meshMats,\n"
"				vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"				vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"				vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"				vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"				vertAlphas,\n"
"#endif\n"
"				triangles\n"
"				// Accelerator_Intersect parameters\n"
"				ACCELERATOR_INTERSECT_PARAM\n"
"				// Light related parameters\n"
"				LIGHTS_PARAM);\n"
"		}\n"
"\n"
"		//------------------------------------------------------------------\n"
"		// Build the next path vertex ray\n"
"		//------------------------------------------------------------------\n"
"\n"
"		float3 sampledDir;\n"
"		float cosSampledDir;\n"
"\n"
"		const float3 bsdfSample = BSDF_Sample(bsdfPathVertexN,\n"
"			Rnd_FloatValue(seed),\n"
"			Rnd_FloatValue(seed),\n"
"			&sampledDir, &lastPdfW, &cosSampledDir, &lastBSDFEvent,\n"
"			ALL\n"
"			MATERIALS_PARAM);\n"
"\n"
"		if (Spectrum_IsBlack(bsdfSample))\n"
"			break;\n"
"\n"
"		// Increment path depth informations\n"
"		PathDepthInfo_IncDepths(depthInfo, lastBSDFEvent);\n"
"\n"
"		// Update volume information\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		PathVolumeInfo_Update(volInfoPathVertexN, lastBSDFEvent, bsdfPathVertexN\n"
"				MATERIALS_PARAM);\n"
"#endif\n"
"\n"
"		// Continue to trace the path\n"
"		const float3 throughputFactor = bsdfSample *\n"
"			((lastBSDFEvent & SPECULAR) ? 1.f : min(1.f, lastPdfW / PARAM_PDF_CLAMP_VALUE));\n"
"		pathThroughput *= throughputFactor;\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"		// Update also irradiance AOV path throughput\n"
"		VSTORE3F(VLOAD3F(sampleResult->irradiancePathThroughput.c) * throughputFactor, sampleResult->irradiancePathThroughput.c);\n"
"#endif\n"
"\n"
"		Ray_Init2_Private(ray, VLOAD3F(&bsdfPathVertexN->hitPoint.p.x), sampledDir, time);\n"
"	}\n"
"\n"
"	return tracedRaysCount;\n"
"}\n"
"\n"
"uint SampleComponent(\n"
"		Seed *seed,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"		__global PathVolumeInfo *volInfoPathVertex1,\n"
"		__global PathVolumeInfo *volInfoPathVertexN,\n"
"		__global PathVolumeInfo *directLightVolInfo,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0) || defined(PARAM_HAS_VOLUMES)\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"		const float time,\n"
"		const BSDFEvent requestedEventTypes,\n"
"		const uint size,\n"
"		const float3 throughputPathVertex1,\n"
"		__global BSDF *bsdfPathVertex1, __global BSDF *bsdfPathVertexN,\n"
"		__global BSDF *directLightBSDF,\n"
"		__global SampleResult *sampleResult,\n"
"		// BSDF_Init parameters\n"
"		__global const Mesh* restrict meshDescs,\n"
"		__global const uint* restrict meshMats,\n"
"		__global const Point* restrict vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"		__global const Vector* restrict vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"		__global const UV* restrict vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"		__global const Spectrum* restrict vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"		__global const float* restrict vertAlphas,\n"
"#endif\n"
"		__global const Triangle* restrict triangles\n"
"		// Accelerator_Intersect parameters\n"
"		ACCELERATOR_INTERSECT_PARAM_DECL\n"
"		// Light related parameters\n"
"		LIGHTS_PARAM_DECL) {\n"
"	uint tracedRaysCount = 0;\n"
"\n"
"	const uint sampleCount = size * size;\n"
"	const float scaleFactor = 1.f / sampleCount;\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"	float indirectShadowMask = 0.f;\n"
"#endif\n"
"	for (uint currentBSDFSampleIndex = 0; currentBSDFSampleIndex < sampleCount; ++currentBSDFSampleIndex) {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"		sampleResult->indirectShadowMask = 1.f;\n"
"#endif\n"
"\n"
"		float u0, u1;\n"
"		SampleGrid(seed, size,\n"
"			currentBSDFSampleIndex % size, currentBSDFSampleIndex / size,\n"
"			&u0, &u1);\n"
"\n"
"		// Sample the BSDF on the first path vertex\n"
"		float3 sampledDir;\n"
"		float pdfW, cosSampledDir;\n"
"		BSDFEvent event;\n"
"\n"
"		const float3 bsdfSample = BSDF_Sample(bsdfPathVertex1,\n"
"			u0,\n"
"			u1,\n"
"			&sampledDir, &pdfW, &cosSampledDir, &event,\n"
"			requestedEventTypes | REFLECT | TRANSMIT\n"
"			MATERIALS_PARAM);\n"
"\n"
"		if (!Spectrum_IsBlack(bsdfSample)) {\n"
"			PathDepthInfo depthInfo;\n"
"			PathDepthInfo_Init(&depthInfo);\n"
"			PathDepthInfo_IncDepths(&depthInfo, event);\n"
"\n"
"			// Update information about the first path BSDF \n"
"			sampleResult->firstPathVertexEvent = event;\n"
"\n"
"			// Update volume information\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"			// I need to work on a copy of volume information of the first path vertex\n"
"			*volInfoPathVertexN = *volInfoPathVertex1;\n"
"			PathVolumeInfo_Update(volInfoPathVertexN, event, bsdfPathVertexN\n"
"					MATERIALS_PARAM);\n"
"#endif\n"
"\n"
"			// Continue to trace the path\n"
"			const float pdfFactor = scaleFactor * ((event & SPECULAR) ? 1.f : min(1.f, pdfW / PARAM_PDF_CLAMP_VALUE));\n"
"			const float3 continuePathThroughput = throughputPathVertex1 * bsdfSample * pdfFactor;\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"			// This is valid for irradiance AOV only if it is not a SPECULAR material and\n"
"			// first path vertex. Set or update sampleResult.irradiancePathThroughput\n"
"			if (!(BSDF_GetEventTypes(bsdfPathVertex1\n"
"						MATERIALS_PARAM) & SPECULAR))\n"
"				VSTORE3F(M_1_PI_F * fabs(dot(\n"
"							VLOAD3F(&bsdfPathVertex1->hitPoint.shadeN.x),\n"
"							sampledDir)),\n"
"						sampleResult->irradiancePathThroughput.c);\n"
"			else\n"
"				VSTORE3F(BLACK, sampleResult->irradiancePathThroughput.c);\n"
"#endif\n"
"\n"
"			Ray continueRay;\n"
"			Ray_Init2_Private(&continueRay, VLOAD3F(&bsdfPathVertex1->hitPoint.p.x), sampledDir, time);\n"
"\n"
"			tracedRaysCount += ContinueTracePath(\n"
"					seed,\n"
"#if defined(PARAM_HAS_VOLUMES)\n"
"					volInfoPathVertexN,\n"
"					directLightVolInfo,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0) || defined(PARAM_HAS_VOLUMES)\n"
"					tmpHitPoint,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"					worldCenterX, worldCenterY, worldCenterZ, worldRadius,\n"
"#endif\n"
"					&depthInfo, &continueRay,\n"
"					time,\n"
"					continuePathThroughput,\n"
"					event, pdfW,\n"
"					bsdfPathVertexN, directLightBSDF,\n"
"					sampleResult,\n"
"					// BSDF_Init parameters\n"
"					meshDescs,\n"
"					meshMats,\n"
"					vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"					vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"					vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"					vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"					vertAlphas,\n"
"#endif\n"
"					triangles\n"
"					// Accelerator_Intersect parameters\n"
"					ACCELERATOR_INTERSECT_PARAM\n"
"					// Light related parameters\n"
"					LIGHTS_PARAM);\n"
"		}\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"		// sampleResult->indirectShadowMask requires special handling: the\n"
"		// end result must be the average of all path results\n"
"		indirectShadowMask += scaleFactor * sampleResult->indirectShadowMask;\n"
"#endif\n"
"	}\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"	sampleResult->indirectShadowMask = indirectShadowMask;\n"
"#endif\n"
"\n"
"	return tracedRaysCount;\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Kernel parameters\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_0)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_0 \\\n"
"		, __global float *filmRadianceGroup0\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_0\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_1)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_1 \\\n"
"		, __global float *filmRadianceGroup1\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_1\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_2)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_2 \\\n"
"		, __global float *filmRadianceGroup2\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_2\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_3)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_3 \\\n"
"		, __global float *filmRadianceGroup3\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_3\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_4)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_4 \\\n"
"		, __global float *filmRadianceGroup4\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_4\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_5)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_5 \\\n"
"		, __global float *filmRadianceGroup5\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_5\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_6)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_6 \\\n"
"		, __global float *filmRadianceGroup6\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_6\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_7)\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_7 \\\n"
"		, __global float *filmRadianceGroup7\n"
"#else\n"
"#define KERNEL_ARGS_FILM_RADIANCE_GROUP_7\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_ALPHA)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_ALPHA \\\n"
"		, __global float *filmAlpha\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_ALPHA\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DEPTH)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DEPTH \\\n"
"		, __global float *filmDepth\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DEPTH\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_POSITION)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_POSITION \\\n"
"		, __global float *filmPosition\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_POSITION\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_GEOMETRY_NORMAL)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_GEOMETRY_NORMAL \\\n"
"		, __global float *filmGeometryNormal\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_GEOMETRY_NORMAL\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_SHADING_NORMAL)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_SHADING_NORMAL \\\n"
"		, __global float *filmShadingNormal\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_SHADING_NORMAL\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_MATERIAL_ID)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_MATERIAL_ID \\\n"
"		, __global uint *filmMaterialID\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_MATERIAL_ID\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_DIFFUSE)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DIRECT_DIFFUSE \\\n"
"		, __global float *filmDirectDiffuse\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DIRECT_DIFFUSE\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_GLOSSY)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DIRECT_GLOSSY \\\n"
"		, __global float *filmDirectGlossy\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DIRECT_GLOSSY\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_EMISSION)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_EMISSION \\\n"
"		, __global float *filmEmission\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_EMISSION\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_DIFFUSE)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_DIFFUSE \\\n"
"		, __global float *filmIndirectDiffuse\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_DIFFUSE\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_GLOSSY)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_GLOSSY \\\n"
"		, __global float *filmIndirectGlossy\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_GLOSSY\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SPECULAR)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_SPECULAR \\\n"
"		, __global float *filmIndirectSpecular\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_SPECULAR\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_MATERIAL_ID_MASK)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_ID_MASK \\\n"
"		, __global float *filmMaterialIDMask\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_ID_MASK\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_SHADOW_MASK)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DIRECT_SHADOW_MASK \\\n"
"		, __global float *filmDirectShadowMask\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_DIRECT_SHADOW_MASK\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_SHADOW_MASK \\\n"
"		, __global float *filmIndirectShadowMask\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_INDIRECT_SHADOW_MASK\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_UV)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_UV \\\n"
"		, __global float *filmUV\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_UV\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_RAYCOUNT)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_RAYCOUNT \\\n"
"		, __global float *filmRayCount\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_RAYCOUNT\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_BY_MATERIAL_ID)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_BY_MATERIAL_ID \\\n"
"		, __global float *filmByMaterialID\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_BY_MATERIAL_ID\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_IRRADIANCE)\n"
"#define KERNEL_ARGS_FILM_CHANNELS_IRRADIANCE \\\n"
"		, __global float *filmIrradiance\n"
"#else\n"
"#define KERNEL_ARGS_FILM_CHANNELS_IRRADIANCE\n"
"#endif\n"
"\n"
"#define KERNEL_ARGS_FILM \\\n"
"		, const uint filmWidth, const uint filmHeight \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_0 \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_1 \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_2 \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_3 \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_4 \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_5 \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_6 \\\n"
"		KERNEL_ARGS_FILM_RADIANCE_GROUP_7 \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_ALPHA \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_DEPTH \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_POSITION \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_GEOMETRY_NORMAL \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_SHADING_NORMAL \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_MATERIAL_ID \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_DIRECT_DIFFUSE \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_DIRECT_GLOSSY \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_EMISSION \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_INDIRECT_DIFFUSE \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_INDIRECT_GLOSSY \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_INDIRECT_SPECULAR \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_ID_MASK \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_DIRECT_SHADOW_MASK \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_INDIRECT_SHADOW_MASK \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_UV \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_RAYCOUNT \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_BY_MATERIAL_ID \\\n"
"		KERNEL_ARGS_FILM_CHANNELS_IRRADIANCE\n"
"\n"
"#if defined(PARAM_HAS_INFINITELIGHTS)\n"
"#define KERNEL_ARGS_INFINITELIGHTS \\\n"
"		, const float worldCenterX \\\n"
"		, const float worldCenterY \\\n"
"		, const float worldCenterZ \\\n"
"		, const float worldRadius\n"
"#else\n"
"#define KERNEL_ARGS_INFINITELIGHTS\n"
"#endif\n"
"\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"#define KERNEL_ARGS_NORMALS_BUFFER \\\n"
"		, __global const Vector* restrict vertNormals\n"
"#else\n"
"#define KERNEL_ARGS_NORMALS_BUFFER\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"#define KERNEL_ARGS_UVS_BUFFER \\\n"
"		, __global const UV* restrict vertUVs\n"
"#else\n"
"#define KERNEL_ARGS_UVS_BUFFER\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"#define KERNEL_ARGS_COLS_BUFFER \\\n"
"		, __global const Spectrum* restrict vertCols\n"
"#else\n"
"#define KERNEL_ARGS_COLS_BUFFER\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"#define KERNEL_ARGS_ALPHAS_BUFFER \\\n"
"		, __global const float* restrict vertAlphas\n"
"#else\n"
"#define KERNEL_ARGS_ALPHAS_BUFFER\n"
"#endif\n"
"\n"
"#if defined(PARAM_HAS_ENVLIGHTS)\n"
"#define KERNEL_ARGS_ENVLIGHTS \\\n"
"		, __global const uint* restrict envLightIndices \\\n"
"		, const uint envLightCount\n"
"#else\n"
"#define KERNEL_ARGS_ENVLIGHTS\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"#define KERNEL_ARGS_INFINITELIGHT \\\n"
"		, __global const float* restrict infiniteLightDistribution\n"
"#else\n"
"#define KERNEL_ARGS_INFINITELIGHT\n"
"#endif\n"
"\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_0)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_0 \\\n"
"		, __global const ImageMap* restrict imageMapDescs, __global const float* restrict imageMapBuff0\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_0\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_1)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_1 \\\n"
"		, __global const float* restrict imageMapBuff1\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_1\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_2)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_2 \\\n"
"		, __global const float* restrict imageMapBuff2\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_2\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_3)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_3 \\\n"
"		, __global const float* restrict imageMapBuff3\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_3\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_4)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_4 \\\n"
"		, __global const float* restrict imageMapBuff4\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_4\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_5)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_5 \\\n"
"		, __global const float* restrict imageMapBuff5\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_5\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_6)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_6 \\\n"
"		, __global const float* restrict imageMapBuff6\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_6\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_7)\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_7 \\\n"
"		, __global const float* restrict imageMapBuff7\n"
"#else\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGE_7\n"
"#endif\n"
"#define KERNEL_ARGS_IMAGEMAPS_PAGES \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_0 \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_1 \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_2 \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_3 \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_4 \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_5 \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_6 \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGE_7\n"
"\n"
"#define KERNEL_ARGS \\\n"
"		const uint engineFilmWidth, const uint engineFilmHeight \\\n"
"		, __global GPUTask *tasks \\\n"
"		, __global GPUTaskDirectLight *tasksDirectLight \\\n"
"		, __global GPUTaskPathVertexN *tasksPathVertexN \\\n"
"		, __global GPUTaskStats *taskStats \\\n"
"		, __global SampleResult *taskResults \\\n"
"		, __global float *pixelFilterDistribution \\\n"
"		/* Film parameters */ \\\n"
"		KERNEL_ARGS_FILM \\\n"
"		/* Scene parameters */ \\\n"
"		KERNEL_ARGS_INFINITELIGHTS \\\n"
"		, __global const Material* restrict mats \\\n"
"		, __global const Texture* restrict texs \\\n"
"		, __global const uint* restrict meshMats \\\n"
"		, __global const Mesh* restrict meshDescs \\\n"
"		, __global const Point* restrict vertices \\\n"
"		KERNEL_ARGS_NORMALS_BUFFER \\\n"
"		KERNEL_ARGS_UVS_BUFFER \\\n"
"		KERNEL_ARGS_COLS_BUFFER \\\n"
"		KERNEL_ARGS_ALPHAS_BUFFER \\\n"
"		, __global const Triangle* restrict triangles \\\n"
"		, __global const Camera* restrict camera \\\n"
"		/* Lights */ \\\n"
"		, __global const LightSource* restrict lights \\\n"
"		KERNEL_ARGS_ENVLIGHTS \\\n"
"		, __global const uint* restrict meshTriLightDefsOffset \\\n"
"		KERNEL_ARGS_INFINITELIGHT \\\n"
"		, __global const float* restrict lightsDistribution \\\n"
"		/* Images */ \\\n"
"		KERNEL_ARGS_IMAGEMAPS_PAGES \\\n"
"		ACCELERATOR_INTERSECT_PARAM_DECL\n"
"\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// To initialize image maps page pointer table\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_0)\n"
"#define INIT_IMAGEMAPS_PAGE_0 imageMapBuff[0] = imageMapBuff0;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_0\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_1)\n"
"#define INIT_IMAGEMAPS_PAGE_1 imageMapBuff[1] = imageMapBuff1;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_1\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_2)\n"
"#define INIT_IMAGEMAPS_PAGE_2 imageMapBuff[2] = imageMapBuff2;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_2\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_3)\n"
"#define INIT_IMAGEMAPS_PAGE_3 imageMapBuff[3] = imageMapBuff3;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_3\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_4)\n"
"#define INIT_IMAGEMAPS_PAGE_4 imageMapBuff[4] = imageMapBuff4;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_4\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_5)\n"
"#define INIT_IMAGEMAPS_PAGE_5 imageMapBuff[5] = imageMapBuff5;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_5\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_6)\n"
"#define INIT_IMAGEMAPS_PAGE_6 imageMapBuff[6] = imageMapBuff6;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_6\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_7)\n"
"#define INIT_IMAGEMAPS_PAGE_7 imageMapBuff[7] = imageMapBuff7;\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGE_7\n"
"#endif\n"
"\n"
"#if defined(PARAM_HAS_IMAGEMAPS)\n"
"#define INIT_IMAGEMAPS_PAGES \\\n"
"	__global const float* restrict imageMapBuff[PARAM_IMAGEMAPS_COUNT]; \\\n"
"	INIT_IMAGEMAPS_PAGE_0 \\\n"
"	INIT_IMAGEMAPS_PAGE_1 \\\n"
"	INIT_IMAGEMAPS_PAGE_2 \\\n"
"	INIT_IMAGEMAPS_PAGE_3 \\\n"
"	INIT_IMAGEMAPS_PAGE_4 \\\n"
"	INIT_IMAGEMAPS_PAGE_5 \\\n"
"	INIT_IMAGEMAPS_PAGE_6 \\\n"
"	INIT_IMAGEMAPS_PAGE_7\n"
"#else\n"
"#define INIT_IMAGEMAPS_PAGES\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// InitSeed Kernel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void InitSeed(\n"
"		uint seedBase,\n"
"		__global GPUTask *tasks) {\n"
"	//if (get_global_id(0) == 0)\n"
"	//	printf(\"sizeof(BSDF) = %dbytes\\n\", sizeof(BSDF));\n"
"	//if (get_global_id(0) == 0)\n"
"	//	printf(\"sizeof(HitPoint) = %dbytes\\n\", sizeof(HitPoint));\n"
"	//if (get_global_id(0) == 0)\n"
"	//	printf(\"sizeof(GPUTask) = %dbytes\\n\", sizeof(GPUTask));\n"
"	//if (get_global_id(0) == 0)\n"
"	//	printf(\"sizeof(SampleResult) = %dbytes\\n\", sizeof(SampleResult));\n"
"\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= PARAM_TASK_COUNT)\n"
"		return;\n"
"\n"
"	// Initialize the task\n"
"	__global GPUTask *task = &tasks[gid];\n"
"\n"
"	// For testing/debugging\n"
"	//MangleMemory((__global unsigned char *)task, sizeof(GPUTask));\n"
"\n"
"	// Initialize random number generator\n"
"	Seed seed;\n"
"	Rnd_Init(seedBase + gid, &seed);\n"
"\n"
"	// Save the seed\n"
"	task->seed.s1 = seed.s1;\n"
"	task->seed.s2 = seed.s2;\n"
"	task->seed.s3 = seed.s3;\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// InitStats Kernel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void InitStat(\n"
"		__global GPUTaskStats *taskStats) {\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= PARAM_TASK_COUNT)\n"
"		return;\n"
"\n"
"	__global GPUTaskStats *taskStat = &taskStats[gid];\n"
"	taskStat->raysCount = 0;\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// MergePixelSamples\n"
"//------------------------------------------------------------------------------\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void MergePixelSamples(\n"
"		const uint tileStartX\n"
"		, const uint tileStartY\n"
"		, const uint engineFilmWidth, const uint engineFilmHeight\n"
"		, __global SampleResult *taskResults\n"
"		// Film parameters\n"
"		KERNEL_ARGS_FILM\n"
"		) {\n"
"	const size_t gid = get_global_id(0);\n"
"\n"
"	uint sampleX, sampleY;\n"
"	sampleX = gid % PARAM_TILE_WIDTH;\n"
"	sampleY = gid / PARAM_TILE_WIDTH;\n"
"\n"
"	if ((gid >= PARAM_TILE_WIDTH * PARAM_TILE_HEIGHT) ||\n"
"			(tileStartX + sampleX >= engineFilmWidth) ||\n"
"			(tileStartY + sampleY >= engineFilmHeight))\n"
"		return;\n"
"\n"
"	const uint index = gid * PARAM_AA_SAMPLES * PARAM_AA_SAMPLES;\n"
"	__global SampleResult *sampleResult = &taskResults[index];\n"
"\n"
"	//--------------------------------------------------------------------------\n"
"	// Initialize Film radiance group pointer table\n"
"	//--------------------------------------------------------------------------\n"
"\n"
"	__global float *filmRadianceGroup[PARAM_FILM_RADIANCE_GROUP_COUNT];\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_0)\n"
"	filmRadianceGroup[0] = filmRadianceGroup0;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_1)\n"
"	filmRadianceGroup[1] = filmRadianceGroup1;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_2)\n"
"	filmRadianceGroup[2] = filmRadianceGroup2;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_3)\n"
"	filmRadianceGroup[3] = filmRadianceGroup3;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_4)\n"
"	filmRadianceGroup[4] = filmRadianceGroup4;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_5)\n"
"	filmRadianceGroup[5] = filmRadianceGroup5;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_6)\n"
"	filmRadianceGroup[6] = filmRadianceGroup6;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_7)\n"
"	filmRadianceGroup[7] = filmRadianceGroup7;\n"
"#endif\n"
"\n"
"	//--------------------------------------------------------------------------\n"
"	// Radiance clamping\n"
"	//--------------------------------------------------------------------------\n"
"\n"
"	// It is now done at tile level inside the TileRepository on the CPU\n"
"\n"
"	//--------------------------------------------------------------------------\n"
"	// Merge all samples and accumulate statistics\n"
"	//--------------------------------------------------------------------------\n"
"\n"
"#if (PARAM_AA_SAMPLES == 1)\n"
"	Film_AddSample(sampleX, sampleY, &sampleResult[0], PARAM_AA_SAMPLES * PARAM_AA_SAMPLES\n"
"			FILM_PARAM);\n"
"#else\n"
"	SampleResult result = sampleResult[0];\n"
"	uint totalRaysCount = 0;\n"
"	for (uint i = 1; i < PARAM_AA_SAMPLES * PARAM_AA_SAMPLES; ++i) {\n"
"		SR_Accumulate(&sampleResult[i], &result);\n"
"	}\n"
"	SR_Normalize(&result, 1.f / (PARAM_AA_SAMPLES * PARAM_AA_SAMPLES));\n"
"\n"
"	// I have to save result in __global space in order to be able\n"
"	// to use Film_AddSample(). OpenCL can be so stupid some time...\n"
"	sampleResult[0] = result;\n"
"	Film_AddSample(sampleX, sampleY, &sampleResult[0], PARAM_AA_SAMPLES * PARAM_AA_SAMPLES\n"
"			FILM_PARAM);\n"
"#endif\n"
"}\n"
; } }
