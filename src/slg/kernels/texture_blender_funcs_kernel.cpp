#include <string>
namespace slg { namespace ocl {
std::string KernelSource_texture_blender_funcs = 
"#line 2 \"texture_blender_funcs.cl\"\n"
"\n"
"/***************************************************************************\n"
" * Copyright 1998-2015 by authors (see AUTHORS.txt)                        *\n"
" *                                                                         *\n"
" *   This file is part of LuxRender.                                       *\n"
" *                                                                         *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");         *\n"
" * you may not use this file except in compliance with the License.        *\n"
" * You may obtain a copy of the License at                                 *\n"
" *                                                                         *\n"
" *     http://www.apache.org/licenses/LICENSE-2.0                          *\n"
" *                                                                         *\n"
" * Unless required by applicable law or agreed to in writing, software     *\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,       *\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*\n"
" * See the License for the specific language governing permissions and     *\n"
" * limitations under the License.                                          *\n"
" ***************************************************************************/\n"
"\n"
"#ifndef TEXTURE_STACK_SIZE\n"
"#define TEXTURE_STACK_SIZE 16\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Blender blend texture\n"
"//------------------------------------------------------------------------------\n"
" \n"
"#if defined(PARAM_ENABLE_BLENDER_BLEND)\n"
" \n"
"float BlenderBlendTexture_Evaluate(__global HitPoint *hitPoint,\n"
"		const ProgressionType type, const bool direction,\n"
" 		const float contrast, const float bright, __global const TextureMapping3D *mapping) {\n"
"	const float3 P = TextureMapping3D_Map(mapping, hitPoint);\n"
" \n"
"	float result = 0.f;\n"
"	float x, y, t;\n"
"     \n"
"	if(!direction) {\n"
"		//horizontal\n"
"		x = P.x;\n"
"		y = P.y;\n"
"	} else {\n"
"		//vertical\n"
"		x = P.y;\n"
"		y = P.x;\n"
"	};\n"
" \n"
"    if (type == TEX_LIN) { /* lin */\n"
"		result = (1.f + x) / 2.f;\n"
"	} else if (type == TEX_QUAD) { /* quad */\n"
"		result = (1.f + x) / 2.f;\n"
"		if (result < 0.f) result = 0.f;\n"
"		else result *= result;\n"
"	} else if (type == TEX_EASE) { /* ease */\n"
"		result = (1.f + x) / 2.f;\n"
"        if (result <= 0.f) result = 0.f;\n"
"        else if (result >= 1.f) result = 1.f;\n"
"        else {\n"
"			t = result * result;\n"
"            result = (3.f * t - 2.f * t * result);\n"
"        }\n"
"    } else if (type == TEX_DIAG) { /* diag */\n"
"		result = (2.f + x + y) / 4.f;\n"
"    } else if (type == TEX_RAD) { /* radial */\n"
"        result = (atan2(y, x) / (2.f * M_PI) + 0.5f);\n"
"    } else { /* sphere TEX_SPHERE */\n"
"        result = 1.f - sqrt(x * x + y * y + P.z * P.z);\n"
"        if (result < 0.f) result = 0.f;\n"
"	    if (type == TEX_HALO) result *= result; /* halo */\n"
"    }\n"
"\n"
"	result = (result - 0.5f) * contrast + bright - 0.5f;\n"
"    if(result < 0.f) result = 0.f; \n"
"	else if(result > 1.f) result = 1.f;\n"
"\n"
"	return result;\n"
"}\n"
"\n"
"float BlenderBlendTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const ProgressionType type, const bool direction,\n"
"		const float contrast, const float bright, __global const TextureMapping3D *mapping) {\n"
"	return BlenderBlendTexture_Evaluate(hitPoint, type, direction, contrast, bright, mapping);\n"
"}\n"
"\n"
"float3 BlenderBlendTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const ProgressionType type, const bool direction,\n"
"		const float contrast, const float bright, __global const TextureMapping3D *mapping) {\n"
"	return BlenderBlendTexture_Evaluate(hitPoint, type, direction, contrast, bright, mapping);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Blender clouds texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_BLENDER_CLOUDS)\n"
"\n"
"float BlenderCloudsTexture_Evaluate(__global HitPoint *hitPoint,\n"
"		const BlenderNoiseBasis noisebasis, const float noisesize, const int noisedepth,\n"
"		const float contrast, const float bright, const bool hard, __global const TextureMapping3D *mapping) {\n"
"	const float3 P = TextureMapping3D_Map(mapping, hitPoint);\n"
"\n"
"	float clouds = BLI_gTurbulence(noisesize, P.x, P.y, P.z, noisedepth, hard, noisebasis);\n"
"\n"
"	clouds = (clouds - 0.5f) * contrast + bright - 0.5f;\n"
"	clouds = clamp(clouds, 0.f, 1.f);\n"
"\n"
"	return clouds;\n"
"}\n"
"\n"
"float BlenderCloudsTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const BlenderNoiseBasis noisebasis, const float noisesize, const int noisedepth,\n"
"		const float contrast, const float bright, const bool hard, __global const TextureMapping3D *mapping) {\n"
"	return BlenderCloudsTexture_Evaluate(hitPoint, noisebasis, noisesize, noisedepth,\n"
"			contrast, bright, hard, mapping);\n"
"}\n"
"\n"
"float3 BlenderCloudsTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const BlenderNoiseBasis noisebasis, const float noisesize, const int noisedepth,\n"
"		const float contrast, const float bright, const bool hard, __global const TextureMapping3D *mapping) {\n"
"	return BlenderCloudsTexture_Evaluate(hitPoint, noisebasis, noisesize, noisedepth,\n"
"			contrast, bright, hard, mapping);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Blender distorted noise texture\n"
"//------------------------------------------------------------------------------\n"
"            \n"
"#if defined(PARAM_ENABLE_BLENDER_DISTORTED_NOISE)\n"
"\n"
"float BlenderDistortedNoiseTexture_Evaluate(__global HitPoint *hitPoint,\n"
"		const BlenderNoiseBasis noisedistortion, const BlenderNoiseBasis noisebasis, const float distortion, const float noisesize,\n"
"		const float contrast, const float bright, __global const TextureMapping3D *mapping) {\n"
"	float3 P = TextureMapping3D_Map(mapping, hitPoint);\n"
"\n"
"	float result = 0.f;\n"
"	float scale = 1.f;\n"
"\n"
"	if(fabs(noisesize) > 0.00001f) scale = (1.f/noisesize);\n"
"	P = scale*P;\n"
"	result = mg_VLNoise(P.x, P.y, P.z, distortion, noisebasis, noisedistortion);\n"
"\n"
"	result = (result - 0.5f) * contrast + bright - 0.5f;\n"
"    if(result < 0.f) result = 0.f; \n"
"	else if(result > 1.f) result = 1.f;\n"
"\n"
"	return result;\n"
"}\n"
"\n"
"float BlenderDistortedNoiseTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const BlenderNoiseBasis noisedistortion, const BlenderNoiseBasis noisebasis, const float distortion, const float noisesize,\n"
"		const float contrast, const float bright, __global const TextureMapping3D *mapping) {\n"
"	return BlenderDistortedNoiseTexture_Evaluate(hitPoint, noisedistortion, noisebasis, distortion, noisesize,\n"
"			contrast, bright, mapping);\n"
"}\n"
"\n"
"float3 BlenderDistortedNoiseTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const BlenderNoiseBasis noisedistortion, const BlenderNoiseBasis noisebasis, const float distortion, const float noisesize,\n"
"		const float contrast, const float bright, __global const TextureMapping3D *mapping) {\n"
"	return BlenderDistortedNoiseTexture_Evaluate(hitPoint, noisedistortion, noisebasis, distortion, noisesize,\n"
"			contrast, bright, mapping);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Blender magic texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_BLENDER_MAGIC)\n"
"float3 BlenderMagicTexture_Evaluate(__global HitPoint *hitPoint, const int noisedepth, const float turbulence, \n"
"			const float contrast, const float bright, __global const TextureMapping3D *mapping) {\n"
"	\n"
"	const float3 P = TextureMapping3D_Map(mapping, hitPoint);\n"
"	float3 s;\n"
"\n"
"    float x, y, z, turb = 1.f;\n"
"    float r, g, b;\n"
"    int n;\n"
"\n"
"    n = noisedepth;\n"
"    turb = turbulence / 5.f;\n"
"\n"
"    x = sin((P.x + P.y + P.z)*5.f);\n"
"    y = cos((-P.x + P.y - P.z)*5.f);\n"
"    z = -cos((-P.x - P.y + P.z)*5.f);\n"
"    if (n > 0) {\n"
"        x *= turb;\n"
"        y *= turb;\n"
"        z *= turb;\n"
"        y = -cos(x - y + z);\n"
"        y *= turb;\n"
"        if (n > 1) {\n"
"            x = cos(x - y - z);\n"
"            x *= turb;\n"
"            if (n > 2) {\n"
"                z = sin(-x - y - z);\n"
"                z *= turb;\n"
"                if (n > 3) {\n"
"                    x = -cos(-x + y - z);\n"
"                    x *= turb;\n"
"                    if (n > 4) {\n"
"                        y = -sin(-x + y + z);\n"
"                        y *= turb;\n"
"                        if (n > 5) {\n"
"                            y = -cos(-x + y + z);\n"
"                            y *= turb;\n"
"                            if (n > 6) {\n"
"                                x = cos(x + y + z);\n"
"                                x *= turb;\n"
"                                if (n > 7) {\n"
"                                    z = sin(x + y - z);\n"
"                                    z *= turb;\n"
"                                    if (n > 8) {\n"
"                                        x = -cos(-x - y + z);\n"
"                                        x *= turb;\n"
"                                        if (n > 9) {\n"
"                                            y = -sin(x - y + z);\n"
"                                            y *= turb;\n"
"                                        }\n"
"                                    }\n"
"                                }\n"
"                            }\n"
"                        }\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    if (turb != 0.f) {\n"
"        turb *= 2.f;\n"
"        x /= turb;\n"
"        y /= turb;\n"
"        z /= turb;\n"
"    }\n"
"    r = 0.5f - x;\n"
"    g = 0.5f - y;\n"
"    b = 0.5f - z;\n"
"\n"
"	r = (r - 0.5f) * contrast + bright - 0.5f;\n"
"    if(r < 0.f) r = 0.f; \n"
"	else if(r > 1.f) r = 1.f;\n"
"\n"
"	g = (g - 0.5f) * contrast + bright - 0.5f;\n"
"    if(g < 0.f) g = 0.f; \n"
"	else if(g > 1.f) g = 1.f;\n"
"\n"
"	b = (b - 0.5f) * contrast + bright - 0.5f;\n"
"    if(b < 0.f) b = 0.f; \n"
"	else if(b > 1.f) b = 1.f;\n"
"\n"
"	s.x = r;\n"
"	s.y = g;\n"
"	s.z = b;\n"
"\n"
"	return s;\n"
"}\n"
"\n"
"float BlenderMagicTexture_ConstEvaluateFloat(__global HitPoint *hitPoint, const int noisedepth, const float turbulence,\n"
"		const float contrast, const float bright, __global const TextureMapping3D *mapping) {\n"
"	float3 result = BlenderMagicTexture_Evaluate(hitPoint, noisedepth, turbulence, contrast, bright, mapping);\n"
"	return (0.212671f * result.x + 0.715160f * result.y + 0.072169f * result.z);\n"
"}\n"
"\n"
"float3 BlenderMagicTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint, const int noisedepth, const float turbulence,\n"
"		const float contrast, const float bright, __global const TextureMapping3D *mapping) {\n"
"	return BlenderMagicTexture_Evaluate(hitPoint, noisedepth, turbulence, contrast, bright, mapping);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Blender marble texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_BLENDER_MARBLE)\n"
"float BlenderMarbleTexture_Evaluate(__global HitPoint *hitPoint, const BlenderMarbleType type, \n"
"		const BlenderNoiseBasis noisebasis, const BlenderNoiseBase noisebasis2, const float noisesize,\n"
"		const float turbulence, const int noisedepth, const float contrast, const float bright,\n"
"		const bool hard, __global const TextureMapping3D *mapping) {\n"
"	\n"
"	const float3 P = TextureMapping3D_Map(mapping, hitPoint);\n"
"\n"
"	float result = 0.f;\n"
"    float n = 5.f * (P.x + P.y + P.z);\n"
"    result = n + turbulence * BLI_gTurbulence(noisesize, P.x, P.y, P.z, noisedepth, hard, noisebasis);\n"
"	\n"
"\n"
"	if(noisebasis2 == TEX_SIN) {\n"
"		result = tex_sin(result);\n"
"	} else if(noisebasis2 == TEX_SAW) {\n"
"		result = tex_saw(result);\n"
"	} else {\n"
"		result = tex_tri(result);\n"
"	}\n"
"	\n"
"	if (type == TEX_SHARP) {\n"
"		result = sqrt(result);\n"
"	} else if (type == TEX_SHARPER) {\n"
"		result = sqrt(sqrt(result));\n"
"	}\n"
"\n"
"	result = (result - 0.5f) * contrast + bright - 0.5f;\n"
"    if(result < 0.f) result = 0.f; \n"
"	else if(result > 1.f) result = 1.f;\n"
"	\n"
"    return result;\n"
"}\n"
"\n"
"float BlenderMarbleTexture_ConstEvaluateFloat(__global HitPoint *hitPoint, const BlenderMarbleType type,\n"
"		const BlenderNoiseBasis noisebasis, const BlenderNoiseBase noisebasis2, const float noisesize, \n"
"		const float turbulence, const int noisedepth, const float contrast, const float bright,\n"
"		const bool hard, __global const TextureMapping3D *mapping) {\n"
"	return BlenderMarbleTexture_Evaluate(hitPoint, type, noisebasis, noisebasis2, noisesize, turbulence, noisedepth, contrast, bright, hard, mapping);\n"
"}\n"
"\n"
"\n"
"float3 BlenderMarbleTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint, const BlenderMarbleType type, \n"
"		const BlenderNoiseBasis noisebasis, const BlenderNoiseBase noisebasis2, const float noisesize, \n"
"		const float turbulence, const int noisedepth, const float contrast, const float bright, \n"
"		const bool hard, __global const TextureMapping3D *mapping) {\n"
"	return BlenderMarbleTexture_Evaluate(hitPoint, type, noisebasis, noisebasis2, noisesize, turbulence, noisedepth, contrast, bright, hard, mapping);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Blender musgrave texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_BLENDER_MUSGRAVE)\n"
"float BlenderMusgraveTexture_Evaluate(__global HitPoint *hitPoint, const BlenderMusgraveType type,\n"
"		const BlenderNoiseBasis noisebasis, const float dimension, const float intensity, const float lacunarity,\n"
"		const float offset, const float gain, const float octaves, const float noisesize,\n"
"		const float contrast, const float bright, __global const TextureMapping3D *mapping) {\n"
"		\n"
"	float scale = 1.f;\n"
"	if(fabs(noisesize) > 0.00001f) scale = (1.f/noisesize);\n"
"	const float3 P = scale*TextureMapping3D_Map(mapping, hitPoint);\n"
"\n"
"	float result = 0.f;\n"
"\n"
"	switch (type) {\n"
"		case TEX_MULTIFRACTAL:\n"
"			result = mg_MultiFractal(P.x, P.y, P.z, dimension, lacunarity, octaves, noisebasis);\n"
"			break;\n"
"		case TEX_FBM:\n"
"			result = mg_fBm(P.x, P.y, P.z, dimension, lacunarity, octaves, noisebasis);\n"
"            break;\n"
"		case TEX_RIDGED_MULTIFRACTAL:\n"
"			result = mg_RidgedMultiFractal(P.x, P.y, P.z, dimension, lacunarity, octaves, offset, gain, noisebasis);\n"
"			break;\n"
"        case TEX_HYBRID_MULTIFRACTAL:\n"
"			result = mg_HybridMultiFractal(P.x, P.y, P.z, dimension, lacunarity, octaves, offset, gain, noisebasis);\n"
"			break;\n"
"        case TEX_HETERO_TERRAIN:\n"
"			result = mg_HeteroTerrain(P.x, P.y, P.z, dimension, lacunarity, octaves, offset, noisebasis);\n"
"			break;\n"
"    };\n"
"\n"
"	result *= intensity;\n"
"           \n"
"	result = (result - 0.5f) * contrast + bright - 0.5f;\n"
"    if(result < 0.f) result = 0.f; \n"
"	else if(result > 1.f) result = 1.f;\n"
"	\n"
"	return result;\n"
"}\n"
"\n"
"float BlenderMusgraveTexture_ConstEvaluateFloat(__global HitPoint *hitPoint, const BlenderMusgraveType type,\n"
"		const BlenderNoiseBasis noisebasis, const float dimension, const float intensity, const float lacunarity,\n"
"		const float offset, const float gain, const float octaves, const float noisesize,\n"
"		const float contrast, const float bright, __global const TextureMapping3D *mapping) {\n"
"	return BlenderMusgraveTexture_Evaluate(hitPoint, type, noisebasis, dimension, intensity, lacunarity,\n"
"			offset, gain, octaves, noisesize, contrast, bright, mapping);\n"
"}\n"
"\n"
"float3 BlenderMusgraveTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint, const BlenderMusgraveType type,\n"
"		const BlenderNoiseBasis noisebasis, const float dimension, const float intensity, const float lacunarity,\n"
"		const float offset, const float gain, const float octaves, const float noisesize,\n"
"		const float contrast, const float bright, __global const TextureMapping3D *mapping) {\n"
"	return BlenderMusgraveTexture_Evaluate(hitPoint, type, noisebasis, dimension, intensity, lacunarity,\n"
"			offset, gain, octaves, noisesize, contrast, bright, mapping);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Blender stucci texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_BLENDER_STUCCI)\n"
"float BlenderStucciTexture_Evaluate(__global HitPoint *hitPoint, const BlenderStucciType type,\n"
"		const BlenderNoiseBasis noisebasis, const float noisesize, const float turbulence, const float contrast,\n"
"		const float bright, const bool hard, __global const TextureMapping3D *mapping) {\n"
"		\n"
"	const float3 P = TextureMapping3D_Map(mapping, hitPoint);\n"
"	\n"
"	float result = 0.f;\n"
"//	neo2068: only nor[2] is used, so normal float variable is sufficient\n"
"//	float nor[3], b2, ofs;\n"
"	float b2, ofs;\n"
"	\n"
"	b2 = BLI_gNoise(noisesize, P.x, P.y, P.z, hard, noisebasis);\n"
"	ofs = turbulence / 200.f;\n"
"\n"
"	if (type != TEX_PLASTIC) ofs *= (b2 * b2);\n"
"//	neo2068: only nor[2] is used\n"
"//    nor[0] = BLI_gNoise(noisesize, P.x + ofs, P.y, P.z, hard, noisebasis);\n"
"//    nor[1] = BLI_gNoise(noisesize, P.x, P.y + ofs, P.z, hard, noisebasis);\n"
"//    nor[2] = BLI_gNoise(noisesize, P.x, P.y, P.z + ofs, hard, noisebasis);\n"
"    result = BLI_gNoise(noisesize, P.x, P.y, P.z + ofs, hard, noisebasis);\n"
"\n"
"//    result = nor[2];\n"
"\n"
"    if (type == TEX_WALL_OUT)\n"
"        result = 1.f - result;\n"
"\n"
"	result = (result - 0.5f) * contrast + bright - 0.5f;\n"
"    if(result < 0.f) result = 0.f; \n"
"	else if(result > 1.f) result = 1.f;\n"
"\n"
"	return result;\n"
"}\n"
"\n"
"float BlenderStucciTexture_ConstEvaluateFloat(__global HitPoint *hitPoint, const BlenderStucciType type,\n"
"		const BlenderNoiseBasis noisebasis, const float noisesize, const float turbulence, const float contrast,\n"
"		const float bright, const bool hard, __global const TextureMapping3D *mapping) {\n"
"	return BlenderStucciTexture_Evaluate(hitPoint, type, noisebasis, noisesize, turbulence,\n"
"			contrast, bright, hard, mapping);\n"
"}\n"
"\n"
"float3 BlenderStucciTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint, const BlenderStucciType type,\n"
"		const BlenderNoiseBasis noisebasis, const float noisesize, const float turbulence, const float contrast,\n"
"		const float bright, const bool hard, __global const TextureMapping3D *mapping) {\n"
"	return BlenderStucciTexture_Evaluate(hitPoint, type, noisebasis, noisesize, turbulence,\n"
"			contrast, bright, hard, mapping);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Blender wood texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_BLENDER_WOOD)\n"
"\n"
"float BlenderWoodTexture_Evaluate(__global HitPoint *hitPoint,\n"
"		const BlenderWoodType type, const BlenderNoiseBase noisebasis2,\n"
"		const BlenderNoiseBasis noisebasis, const float noisesize, const float turbulence,\n"
"		const float contrast, const float bright, const bool hard,\n"
"		__global const TextureMapping3D *mapping) {\n"
"	const float3 P = TextureMapping3D_Map(mapping, hitPoint);\n"
"\n"
"	float wood = 0.f;\n"
"	switch(type) {\n"
"		default:\n"
"		case BANDS:\n"
"			if(noisebasis2 == TEX_SIN) {\n"
"				wood = tex_sin((P.x + P.y + P.z) * 10.f);\n"
"			} else if(noisebasis2 == TEX_SAW) {\n"
"				wood = tex_saw((P.x + P.y + P.z) * 10.f);\n"
"			} else {\n"
"				wood = tex_tri((P.x + P.y + P.z) * 10.f);\n"
"			}\n"
"			break;\n"
"		case RINGS:\n"
"			if(noisebasis2 == TEX_SIN) {\n"
"				wood = tex_sin(sqrt(P.x*P.x + P.y*P.y + P.z*P.z) * 20.f);\n"
"			} else if(noisebasis2 == TEX_SAW) {\n"
"				wood = tex_saw(sqrt(P.x*P.x + P.y*P.y + P.z*P.z) * 20.f);\n"
"			} else {\n"
"				wood = tex_tri(sqrt(P.x*P.x + P.y*P.y + P.z*P.z) * 20.f);\n"
"			}\n"
"			break;\n"
"		case BANDNOISE:			\n"
"			if(hard)	\n"
"				wood = turbulence * fabs(2.f * BLI_gNoise(noisesize, P.x, P.y, P.z, hard, noisebasis) - 1.f);\n"
"			else\n"
"				wood = turbulence * BLI_gNoise(noisesize, P.x, P.y, P.z, hard, noisebasis);\n"
"\n"
"			if(noisebasis2 == TEX_SIN) {\n"
"				wood = tex_sin((P.x + P.y + P.z) * 10.f + wood);\n"
"			} else if(noisebasis2 == TEX_SAW) {\n"
"				wood = tex_saw((P.x + P.y + P.z) * 10.f + wood);\n"
"			} else {\n"
"				wood = tex_tri((P.x + P.y + P.z) * 10.f + wood);\n"
"			}\n"
"			break;\n"
"		case RINGNOISE:\n"
"			if(hard)	\n"
"				wood = turbulence * fabs(2.f * BLI_gNoise(noisesize, P.x, P.y, P.z, hard, noisebasis) - 1.f);\n"
"			else\n"
"				wood = turbulence * BLI_gNoise(noisesize, P.x, P.y, P.z, hard, noisebasis);\n"
"\n"
"			if(noisebasis2 == TEX_SIN) {\n"
"				wood = tex_sin(sqrt(P.x*P.x + P.y*P.y + P.z*P.z) * 20.f + wood);\n"
"			} else if(noisebasis2 == TEX_SAW) {\n"
"				wood = tex_saw(sqrt(P.x*P.x + P.y*P.y + P.z*P.z) * 20.f + wood);\n"
"			} else {\n"
"				wood = tex_tri(sqrt(P.x*P.x + P.y*P.y + P.z*P.z) * 20.f + wood);\n"
"			}\n"
"			break;\n"
"	}\n"
"	wood = (wood - 0.5f) * contrast + bright - 0.5f;\n"
"	wood = clamp(wood, 0.f, 1.f);\n"
"\n"
"	return wood;\n"
"}\n"
"\n"
"float BlenderWoodTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const BlenderWoodType type, const BlenderNoiseBase noisebasis2,\n"
"		const BlenderNoiseBasis noisebasis, const float noisesize, const float turbulence,\n"
"		const float contrast, const float bright, const bool hard,\n"
"		__global const TextureMapping3D *mapping) {\n"
"	return BlenderWoodTexture_Evaluate(hitPoint, type, noisebasis2, noisebasis,\n"
"		noisesize, turbulence, contrast, bright, hard, mapping);\n"
"}\n"
"\n"
"float3 BlenderWoodTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const BlenderWoodType type, const BlenderNoiseBase noisebasis2, \n"
"		const BlenderNoiseBasis noisebasis, const float noisesize, const float turbulence,\n"
"		const float contrast, const float bright, const bool hard,\n"
"		__global const TextureMapping3D *mapping) {\n"
"    return BlenderWoodTexture_Evaluate(hitPoint, type, noisebasis2, noisebasis,\n"
"		noisesize, turbulence, contrast, bright, hard, mapping);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Blender voronoi texture\n"
"//------------------------------------------------------------------------------\n"
" \n"
"#if defined(PARAM_ENABLE_BLENDER_VORONOI)\n"
" \n"
"float BlenderVoronoiTexture_Evaluate(__global HitPoint *hitPoint,\n"
"		const DistanceMetric distancemetric, const float feature_weight1, const float feature_weight2, \n"
"		const float feature_weight3, const float feature_weight4, const float noisesize, const float intensity,\n"
"		const float exponent, const float contrast, const float bright, __global const TextureMapping3D *mapping) {\n"
"\n"
"    float da[4], pa[12]; /* distance and point coordinate arrays of 4 nearest neighbours */\n"
"	float scale = 1.f;\n"
"	if(fabs(noisesize) > 0.00001f) scale = (1.f/noisesize);\n"
"	const float3 P = scale*TextureMapping3D_Map(mapping, hitPoint);\n"
" \n"
"	const float aw1 = fabs(feature_weight1);\n"
"    const float aw2 = fabs(feature_weight2);\n"
"    const float aw3 = fabs(feature_weight3);\n"
"    const float aw4 = fabs(feature_weight4);\n"
"\n"
"    float sc = (aw1 + aw2 + aw3 + aw4);\n"
"\n"
"    if (sc > 0.00001f) sc = intensity / sc;\n"
"\n"
"    float result = 1.f;\n"
"\n"
"	voronoi(P.x, P.y, P.z, da, pa, exponent, distancemetric);\n"
"    result = sc * fabs(feature_weight1 * da[0] + feature_weight2 * da[1] + feature_weight3 * da[2] + feature_weight4 * da[3]);\n"
"\n"
"	result = (result - 0.5f) * contrast + bright - 0.5f;\n"
"    if(result < 0.f) result = 0.f; \n"
"	else if(result > 1.f) result = 1.f;\n"
"\n"
"    return result;\n"
"}\n"
"		\n"
"float BlenderVoronoiTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,	const DistanceMetric distancemetric, const float feature_weight1, \n"
"		const float feature_weight2, const float feature_weight3, const float feature_weight4, const float noisesize, const float intensity,\n"
"		const float exponent, const float contrast, const float bright, __global const TextureMapping3D *mapping) {	\n"
"	return BlenderVoronoiTexture_Evaluate(hitPoint, distancemetric, feature_weight1, feature_weight2, feature_weight3, feature_weight4,\n"
"		noisesize, intensity, exponent, contrast, bright, mapping);\n"
"}\n"
" \n"
"float3 BlenderVoronoiTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint, const DistanceMetric distancemetric, const float feature_weight1,\n"
"		const float feature_weight2, const float feature_weight3, const float feature_weight4, const float noisesize, const float intensity,\n"
"		const float exponent, const float contrast, const float bright, __global const TextureMapping3D *mapping) {\n"
"	return BlenderVoronoiTexture_Evaluate(hitPoint, distancemetric, feature_weight1, feature_weight2, feature_weight3, feature_weight4,\n"
"		noisesize, intensity, exponent, contrast, bright, mapping);\n"
"}\n"
" \n"
"#endif\n"
; } }
