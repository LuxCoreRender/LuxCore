#include <string>
namespace slg { namespace ocl {
std::string KernelSource_texture_funcs = 
"#line 2 \"texture_funcs.cl\"\n"
"\n"
"/***************************************************************************\n"
" * Copyright 1998-2013 by authors (see AUTHORS.txt)                        *\n"
" *                                                                         *\n"
" *   This file is part of LuxRender.                                       *\n"
" *                                                                         *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");         *\n"
" * you may not use this file except in compliance with the License.        *\n"
" * You may obtain a copy of the License at                                 *\n"
" *                                                                         *\n"
" *     http://www.apache.org/licenses/LICENSE-2.0                          *\n"
" *                                                                         *\n"
" * Unless required by applicable law or agreed to in writing, software     *\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,       *\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*\n"
" * See the License for the specific language governing permissions and     *\n"
" * limitations under the License.                                          *\n"
" ***************************************************************************/\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"#ifndef TEXTURE_STACK_SIZE\n"
"#define TEXTURE_STACK_SIZE 16\n"
"#endif\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// ImageMaps support\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_HAS_IMAGEMAPS)\n"
"\n"
"__global void *ImageMap_GetPixelsAddress(__global float **imageMapBuff,\n"
"		const uint page, const uint offset) {\n"
"	return &imageMapBuff[page][offset];\n"
"}\n"
"\n"
"float ImageMap_GetTexel_Float(\n"
"		const ImageMapStorageType storageType,\n"
"		__global void *pixels,\n"
"		const uint width, const uint height, const uint channelCount,\n"
"		const int s, const int t) {\n"
"	const uint u = Mod(s, width);\n"
"	const uint v = Mod(t, height);\n"
"\n"
"	const uint index = v * width + u;\n"
"\n"
"	switch (storageType) {\n"
"		case BYTE: {\n"
"			switch (channelCount) {\n"
"				case 1: {\n"
"					const uchar a = ((__global uchar *)pixels)[index];\n"
"					return a * (1.f / 255.f);\n"
"				}\n"
"				case 2: {\n"
"					const uchar a = ((__global uchar *)pixels)[index * 2];\n"
"					return a * (1.f / 255.f);\n"
"				}\n"
"				case 3: {\n"
"					__global uchar *rgb = &((__global uchar *)pixels)[index * 3];\n"
"					return Spectrum_Y((float3)(rgb[0] * (1.f / 255.f), rgb[1] * (1.f / 255.f), rgb[2] * (1.f / 255.f)));\n"
"				}\n"
"				case 4: {\n"
"					__global uchar *rgba = &((__global uchar *)pixels)[index * 4];\n"
"					return Spectrum_Y((float3)(rgba[0] * (1.f / 255.f), rgba[1] * (1.f / 255.f), rgba[2] * (1.f / 255.f)));\n"
"				}\n"
"				default:\n"
"					return 0.f;\n"
"			}\n"
"		}\n"
"		case HALF: {\n"
"			switch (channelCount) {\n"
"				case 1: {\n"
"					return vload_half(index, (__global half *)pixels);\n"
"				}\n"
"				case 2: {\n"
"					return vload_half(index * 2, (__global half *)pixels);\n"
"				}				\n"
"				case 3: {\n"
"					return Spectrum_Y((float3)(\n"
"							vload_half(index * 3, (__global half *)pixels),\n"
"							vload_half(index * 3 + 1, (__global half *)pixels),\n"
"							vload_half(index * 3 + 2, (__global half *)pixels)));\n"
"				}\n"
"				case 4: {\n"
"					return Spectrum_Y((float3)(\n"
"							vload_half(index * 4, (__global half *)pixels),\n"
"							vload_half(index * 4 + 1, (__global half *)pixels),\n"
"							vload_half(index * 4 + 2, (__global half *)pixels)));\n"
"				}\n"
"				default:\n"
"					return 0.f;\n"
"			}\n"
"		}\n"
"		case FLOAT: {\n"
"			switch (channelCount) {\n"
"				case 1: {\n"
"					const float a = ((__global float *)pixels)[index];\n"
"					return a;\n"
"				}\n"
"				case 2: {\n"
"					const float a = ((__global float *)pixels)[index * 2];\n"
"					return a;\n"
"				}\n"
"				case 3: {\n"
"					__global float *rgb = &((__global float *)pixels)[index * 3];\n"
"					return Spectrum_Y((float3)(rgb[0], rgb[1], rgb[2]));\n"
"				}\n"
"				case 4: {\n"
"					__global float *rgba = &((__global float *)pixels)[index * 4];\n"
"					return Spectrum_Y((float3)(rgba[0], rgba[1], rgba[2]));\n"
"				}\n"
"				default:\n"
"					return 0.f;\n"
"			}\n"
"		}\n"
"		default:\n"
"			return 0.f;\n"
"	}\n"
"}\n"
"\n"
"float3 ImageMap_GetTexel_Spectrum(\n"
"		const ImageMapStorageType storageType,\n"
"		__global void *pixels,\n"
"		const uint width, const uint height, const uint channelCount,\n"
"		const int s, const int t) {\n"
"	const uint u = Mod(s, width);\n"
"	const uint v = Mod(t, height);\n"
"\n"
"	const uint index = v * width + u;\n"
"\n"
"	switch (storageType) {\n"
"		case BYTE: {\n"
"			switch (channelCount) {\n"
"				case 1: {\n"
"					const uchar a = ((__global uchar *)pixels)[index];\n"
"					return a * (1.f / 255.f);\n"
"				}\n"
"				case 2: {\n"
"					const uchar a = ((__global uchar *)pixels)[index * 2] * (1.f / 255.f);\n"
"					return a;\n"
"				}\n"
"				case 3: {\n"
"					__global uchar *rgb = &((__global uchar *)pixels)[index * 3];\n"
"					return (float3)(rgb[0] * (1.f / 255.f), rgb[1] * (1.f / 255.f), rgb[2] * (1.f / 255.f));\n"
"				}\n"
"				case 4: {\n"
"					__global uchar *rgba = &((__global uchar *)pixels)[index * 4];\n"
"					return (float3)(rgba[0] * (1.f / 255.f), rgba[1] * (1.f / 255.f), rgba[2] * (1.f / 255.f));\n"
"				}\n"
"				default:\n"
"					return 0.f;\n"
"			}\n"
"		}\n"
"		case HALF: {\n"
"			switch (channelCount) {\n"
"				case 1: {\n"
"					return vload_half(index, (__global half *)pixels);\n"
"				}\n"
"				case 2: {\n"
"					return vload_half(index * 2, (__global half *)pixels);\n"
"				}\n"
"				case 3: {\n"
"					return (float3)(\n"
"							vload_half(index * 3, (__global half *)pixels),\n"
"							vload_half(index * 3 + 1, (__global half *)pixels),\n"
"							vload_half(index * 3 + 2, (__global half *)pixels));\n"
"				}\n"
"				case 4: {\n"
"					return (float3)(\n"
"							vload_half(index * 4, (__global half *)pixels),\n"
"							vload_half(index * 4 + 1, (__global half *)pixels),\n"
"							vload_half(index * 4 + 2, (__global half *)pixels));\n"
"				}\n"
"				default:\n"
"					return 0.f;\n"
"			}\n"
"		}\n"
"		case FLOAT: {\n"
"			switch (channelCount) {\n"
"				case 1: {\n"
"					const float a = ((__global float *)pixels)[index];\n"
"					return a;\n"
"				}\n"
"				case 2: {\n"
"					const float a = ((__global float *)pixels)[index * 2];\n"
"					return a;\n"
"				}\n"
"				case 3: {\n"
"					__global float *rgb = &((__global float *)pixels)[index * 3];\n"
"					return (float3)(rgb[0], rgb[1], rgb[2]);\n"
"				}\n"
"				case 4: {\n"
"					__global float *rgba = &((__global float *)pixels)[index * 4];\n"
"					return (float3)(rgba[0], rgba[1], rgba[2]);\n"
"				}\n"
"				default:\n"
"					return 0.f;\n"
"			}\n"
"		}\n"
"		default:\n"
"			return 0.f;\n"
"	}\n"
"}\n"
"\n"
"float ImageMap_GetFloat(__global ImageMap *imageMap,\n"
"		const float u, const float v\n"
"		IMAGEMAPS_PARAM_DECL) {\n"
"	__global void *pixels = ImageMap_GetPixelsAddress(\n"
"		imageMapBuff, imageMap->pageIndex, imageMap->pixelsIndex);\n"
"	const ImageMapStorageType storageType = imageMap->storageType;\n"
"	const uint channelCount = imageMap->channelCount;\n"
"	const uint width = imageMap->width;\n"
"	const uint height = imageMap->height;\n"
"\n"
"	const float s = u * width - 0.5f;\n"
"	const float t = v * height - 0.5f;\n"
"\n"
"	const int s0 = Floor2Int(s);\n"
"	const int t0 = Floor2Int(t);\n"
"\n"
"	const float ds = s - s0;\n"
"	const float dt = t - t0;\n"
"\n"
"	const float ids = 1.f - ds;\n"
"	const float idt = 1.f - dt;\n"
"\n"
"	const float c0 = ImageMap_GetTexel_Float(storageType, pixels, width, height, channelCount, s0, t0);\n"
"	const float c1 = ImageMap_GetTexel_Float(storageType, pixels, width, height, channelCount, s0, t0 + 1);\n"
"	const float c2 = ImageMap_GetTexel_Float(storageType, pixels, width, height, channelCount, s0 + 1, t0);\n"
"	const float c3 = ImageMap_GetTexel_Float(storageType, pixels, width, height, channelCount, s0 + 1, t0 + 1);\n"
"\n"
"	const float k0 = ids * idt;\n"
"	const float k1 = ids * dt;\n"
"	const float k2 = ds * idt;\n"
"	const float k3 = ds * dt;\n"
"\n"
"	return (k0 * c0 + k1 *c1 + k2 * c2 + k3 * c3);\n"
"}\n"
"\n"
"float3 ImageMap_GetSpectrum(__global ImageMap *imageMap,\n"
"		const float u, const float v\n"
"		IMAGEMAPS_PARAM_DECL) {\n"
"	__global void *pixels = ImageMap_GetPixelsAddress(\n"
"		imageMapBuff, imageMap->pageIndex, imageMap->pixelsIndex);\n"
"	const ImageMapStorageType storageType = imageMap->storageType;\n"
"	const uint channelCount = imageMap->channelCount;\n"
"	const uint width = imageMap->width;\n"
"	const uint height = imageMap->height;\n"
"\n"
"	const float s = u * width - 0.5f;\n"
"	const float t = v * height - 0.5f;\n"
"\n"
"	const int s0 = Floor2Int(s);\n"
"	const int t0 = Floor2Int(t);\n"
"\n"
"	const float ds = s - s0;\n"
"	const float dt = t - t0;\n"
"\n"
"	const float ids = 1.f - ds;\n"
"	const float idt = 1.f - dt;\n"
"\n"
"	const float3 c0 = ImageMap_GetTexel_Spectrum(storageType, pixels, width, height, channelCount, s0, t0);\n"
"	const float3 c1 = ImageMap_GetTexel_Spectrum(storageType, pixels, width, height, channelCount, s0, t0 + 1);\n"
"	const float3 c2 = ImageMap_GetTexel_Spectrum(storageType, pixels, width, height, channelCount, s0 + 1, t0);\n"
"	const float3 c3 = ImageMap_GetTexel_Spectrum(storageType, pixels, width, height, channelCount, s0 + 1, t0 + 1);\n"
"\n"
"	const float k0 = ids * idt;\n"
"	const float k1 = ids * dt;\n"
"	const float k2 = ds * idt;\n"
"	const float k3 = ds * dt;\n"
"\n"
"	return (k0 * c0 + k1 *c1 + k2 * c2 + k3 * c3);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// ConstFloat texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_TEX_CONST_FLOAT)\n"
"\n"
"float ConstFloatTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const float value) {\n"
"	return value;\n"
"}\n"
"\n"
"float3 ConstFloatTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const float value) {\n"
"	return value;\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void ConstFloatTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = ConstFloatTexture_ConstEvaluateFloat(hitPoint,\n"
"			texture->constFloat.value);\n"
"}\n"
"\n"
"void ConstFloatTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = ConstFloatTexture_ConstEvaluateSpectrum(hitPoint,\n"
"			texture->constFloat.value);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// ConstFloat3 texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_TEX_CONST_FLOAT3)\n"
"\n"
"float ConstFloat3Texture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const float3 value) {\n"
"	return Spectrum_Y(value);\n"
"}\n"
"\n"
"float3 ConstFloat3Texture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const float3 value) {\n"
"	return value;\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void ConstFloat3Texture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = ConstFloat3Texture_ConstEvaluateFloat(hitPoint,\n"
"			VLOAD3F(texture->constFloat3.color.c));\n"
"}\n"
"\n"
"void ConstFloat3Texture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = ConstFloat3Texture_ConstEvaluateSpectrum(hitPoint,\n"
"			VLOAD3F(texture->constFloat3.color.c));\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// ImageMap texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_TEX_IMAGEMAP)\n"
"\n"
"float ImageMapTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const float gain, const uint imageMapIndex, __global TextureMapping2D *mapping\n"
"		IMAGEMAPS_PARAM_DECL) {\n"
"	__global ImageMap *imageMap = &imageMapDescs[imageMapIndex];\n"
"\n"
"	const float2 uv = VLOAD2F(&hitPoint->uv.u);\n"
"	const float2 mapUV = TextureMapping2D_Map(mapping, hitPoint);\n"
"\n"
"	return gain * ImageMap_GetFloat(\n"
"			imageMap,\n"
"			mapUV.s0, mapUV.s1\n"
"			IMAGEMAPS_PARAM);\n"
"}\n"
"\n"
"float3 ImageMapTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const float gain, const uint imageMapIndex, __global TextureMapping2D *mapping\n"
"		IMAGEMAPS_PARAM_DECL) {\n"
"	__global ImageMap *imageMap = &imageMapDescs[imageMapIndex];\n"
"	__global float *pixels = ImageMap_GetPixelsAddress(\n"
"			imageMapBuff, imageMap->pageIndex, imageMap->pixelsIndex);\n"
"\n"
"	const float2 uv = VLOAD2F(&hitPoint->uv.u);\n"
"	const float2 mapUV = TextureMapping2D_Map(mapping, hitPoint);\n"
"\n"
"	return gain * ImageMap_GetSpectrum(\n"
"			imageMap,\n"
"			mapUV.s0, mapUV.s1\n"
"			IMAGEMAPS_PARAM);\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void ImageMapTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize\n"
"		IMAGEMAPS_PARAM_DECL) {\n"
"	texValues[(*texValuesSize)++] = ImageMapTexture_ConstEvaluateFloat(hitPoint,\n"
"			texture->imageMapTex.gain, texture->imageMapTex.imageMapIndex,\n"
"			&texture->imageMapTex.mapping\n"
"			IMAGEMAPS_PARAM);\n"
"}\n"
"\n"
"void ImageMapTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize\n"
"		IMAGEMAPS_PARAM_DECL) {\n"
"	texValues[(*texValuesSize)++] =  ImageMapTexture_ConstEvaluateSpectrum(hitPoint,\n"
"			texture->imageMapTex.gain, texture->imageMapTex.imageMapIndex,\n"
"			&texture->imageMapTex.mapping\n"
"			IMAGEMAPS_PARAM);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Scale texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_TEX_SCALE)\n"
"\n"
"float ScaleTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const float tex1, const float tex2) {\n"
"	return tex1 * tex2;\n"
"}\n"
"\n"
"float3 ScaleTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const float3 tex1, const float3 tex2) {\n"
"	return tex1 * tex2;\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"\n"
"void ScaleTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float tex1 = texValues[--(*texValuesSize)];\n"
"	const float tex2 = texValues[--(*texValuesSize)];\n"
"	\n"
"	texValues[(*texValuesSize)++] = ScaleTexture_ConstEvaluateFloat(hitPoint, tex1, tex2);\n"
"}\n"
"\n"
"void ScaleTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float3 tex1 = texValues[--(*texValuesSize)];\n"
"	const float3 tex2 = texValues[--(*texValuesSize)];\n"
"	\n"
"	texValues[(*texValuesSize)++] = ScaleTexture_ConstEvaluateSpectrum(hitPoint, tex1, tex2);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// FresnelApproxN & FresnelApproxK texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_FRESNEL_APPROX_N)\n"
"\n"
"float FresnelApproxN(const float Fr) {\n"
"	const float sqrtReflectance = sqrt(clamp(Fr, 0.f, .999f));\n"
"\n"
"	return (1.f + sqrtReflectance) /\n"
"		(1.f - sqrtReflectance);\n"
"}\n"
"\n"
"float3 FresnelApproxN3(const float3 Fr) {\n"
"	const float3 sqrtReflectance = Spectrum_Sqrt(clamp(Fr, 0.f, .999f));\n"
"\n"
"	return (WHITE + sqrtReflectance) /\n"
"		(WHITE - sqrtReflectance);\n"
"}\n"
"\n"
"float FresnelApproxNTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const float value) {\n"
"	return FresnelApproxN(value);\n"
"}\n"
"\n"
"float3 FresnelApproxNTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const float3 value) {\n"
"	return FresnelApproxN3(value);\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void FresnelApproxNTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float value = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = FresnelApproxNTexture_ConstEvaluateFloat(hitPoint, value);\n"
"}\n"
"\n"
"void FresnelApproxNTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float3 value = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = FresnelApproxNTexture_ConstEvaluateSpectrum(hitPoint, value);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"#if defined(PARAM_ENABLE_FRESNEL_APPROX_K)\n"
"\n"
"float FresnelApproxK(const float Fr) {\n"
"	const float reflectance = clamp(Fr, 0.f, .999f);\n"
"\n"
"	return 2.f * sqrt(reflectance /\n"
"		(1.f - reflectance));\n"
"}\n"
"\n"
"float3 FresnelApproxK3(const float3 Fr) {\n"
"	const float3 reflectance = clamp(Fr, 0.f, .999f);\n"
"\n"
"	return 2.f * Spectrum_Sqrt(reflectance /\n"
"		(WHITE - reflectance));\n"
"}\n"
"\n"
"float FresnelApproxKTexture_ConstEvaluateFloat( __global HitPoint *hitPoint,\n"
"		const float value) {\n"
"	return FresnelApproxK(value);\n"
"}\n"
"\n"
"float3 FresnelApproxKTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const float3 value) {\n"
"	return FresnelApproxK3(value);\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void FresnelApproxKTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float value = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = FresnelApproxKTexture_ConstEvaluateFloat(hitPoint, value);\n"
"}\n"
"\n"
"void FresnelApproxKTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float3 value = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = FresnelApproxKTexture_ConstEvaluateSpectrum(hitPoint, value);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Mix texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_TEX_MIX)\n"
"\n"
"float MixTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const float amt, const float value1, const float value2) {\n"
"	return Lerp(clamp(amt, 0.f, 1.f), value1, value2);\n"
"}\n"
"\n"
"float3 MixTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const float3 amt, const float3 value1, const float3 value2) {\n"
"	return mix(value1, value2, clamp(amt, 0.f, 1.f));\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void MixTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float amt = texValues[--(*texValuesSize)];\n"
"	const float value1 = texValues[--(*texValuesSize)];\n"
"	const float value2 = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = MixTexture_ConstEvaluateFloat(hitPoint, amt, value1, value2);\n"
"}\n"
"\n"
"void MixTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float3 amt = texValues[--(*texValuesSize)];\n"
"	const float3 value1 = texValues[--(*texValuesSize)];\n"
"	const float3 value2 = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = MixTexture_ConstEvaluateSpectrum(hitPoint, amt, value1, value2);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// CheckerBoard 2D & 3D texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_CHECKERBOARD2D)\n"
"\n"
"float CheckerBoard2DTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const float value1, const float value2, __global TextureMapping2D *mapping) {\n"
"	const float2 uv = VLOAD2F(&hitPoint->uv.u);\n"
"	const float2 mapUV = TextureMapping2D_Map(mapping, hitPoint);\n"
"\n"
"	return ((Floor2Int(mapUV.s0) + Floor2Int(mapUV.s1)) % 2 == 0) ? value1 : value2;\n"
"}\n"
"\n"
"float3 CheckerBoard2DTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const float3 value1, const float3 value2, __global TextureMapping2D *mapping) {\n"
"	const float2 uv = VLOAD2F(&hitPoint->uv.u);\n"
"	const float2 mapUV = TextureMapping2D_Map(mapping, hitPoint);\n"
"\n"
"	return ((Floor2Int(mapUV.s0) + Floor2Int(mapUV.s1)) % 2 == 0) ? value1 : value2;\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void CheckerBoard2DTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float value1 = texValues[--(*texValuesSize)];\n"
"	const float value2 = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = CheckerBoard2DTexture_ConstEvaluateFloat(\n"
"			hitPoint, value1, value2, &texture->checkerBoard2D.mapping);\n"
"}\n"
"\n"
"void CheckerBoard2DTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float3 value1 = texValues[--(*texValuesSize)];\n"
"	const float3 value2 = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = CheckerBoard2DTexture_ConstEvaluateSpectrum(\n"
"			hitPoint, value1, value2, &texture->checkerBoard2D.mapping);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"#if defined(PARAM_ENABLE_CHECKERBOARD3D)\n"
"\n"
"float CheckerBoard3DTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const float value1, const float value2, __global TextureMapping3D *mapping) {\n"
"	const float3 mapP = TextureMapping3D_Map(mapping, hitPoint);\n"
"\n"
"	return ((Floor2Int(mapP.x) + Floor2Int(mapP.y) + Floor2Int(mapP.z)) % 2 == 0) ? value1 : value2;\n"
"}\n"
"\n"
"float3 CheckerBoard3DTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const float3 value1, const float3 value2, __global TextureMapping3D *mapping) {\n"
"	const float3 mapP = TextureMapping3D_Map(mapping, hitPoint);\n"
"\n"
"	return ((Floor2Int(mapP.x) + Floor2Int(mapP.y) + Floor2Int(mapP.z)) % 2 == 0) ? value1 : value2;\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void CheckerBoard3DTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float value1 = texValues[--(*texValuesSize)];\n"
"	const float value2 = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = CheckerBoard3DTexture_ConstEvaluateFloat(\n"
"			hitPoint, value1, value2, &texture->checkerBoard3D.mapping);\n"
"}\n"
"\n"
"void CheckerBoard3DTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float3 value1 = texValues[--(*texValuesSize)];\n"
"	const float3 value2 = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = CheckerBoard3DTexture_ConstEvaluateSpectrum(\n"
"			hitPoint, value1, value2, &texture->checkerBoard3D.mapping);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// FBM texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_FBM_TEX)\n"
"\n"
"float FBMTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const float omega, const int octaves, __global TextureMapping3D *mapping) {\n"
"	const float3 mapP = TextureMapping3D_Map(mapping, hitPoint);\n"
"\n"
"	return FBm(mapP, omega, octaves);\n"
"}\n"
"\n"
"float3 FBMTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const float omega, const int octaves, __global TextureMapping3D *mapping) {\n"
"	const float3 mapP = TextureMapping3D_Map(mapping, hitPoint);\n"
"\n"
"	return FBm(mapP, omega, octaves);\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void FBMTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = FBMTexture_ConstEvaluateFloat(hitPoint,\n"
"			texture->fbm.omega, texture->fbm.octaves, &texture->fbm.mapping);\n"
"}\n"
"\n"
"void FBMTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = FBMTexture_ConstEvaluateSpectrum(hitPoint,\n"
"			texture->fbm.omega, texture->fbm.octaves, &texture->fbm.mapping);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Marble texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_MARBLE)\n"
"\n"
"// Evaluate marble spline at _t_\n"
"__constant float MarbleTexture_c[9][3] = {\n"
"	{ .58f, .58f, .6f},\n"
"	{ .58f, .58f, .6f},\n"
"	{ .58f, .58f, .6f},\n"
"	{ .5f, .5f, .5f},\n"
"	{ .6f, .59f, .58f},\n"
"	{ .58f, .58f, .6f},\n"
"	{ .58f, .58f, .6f},\n"
"	{.2f, .2f, .33f},\n"
"	{ .58f, .58f, .6f}\n"
"};\n"
"\n"
"float3 MarbleTexture_Evaluate(__global HitPoint *hitPoint, const float scale,\n"
"		const float omega, const int octaves, const float variation,\n"
"		__global TextureMapping3D *mapping) {\n"
"	const float3 P = scale * TextureMapping3D_Map(mapping, hitPoint);\n"
"\n"
"	float marble = P.y + variation * FBm(P, omega, octaves);\n"
"	float t = .5f + .5f * sin(marble);\n"
"#define NC  sizeof(MarbleTexture_c) / sizeof(MarbleTexture_c[0])\n"
"#define NSEG (NC-3)\n"
"	const int first = Floor2Int(t * NSEG);\n"
"	t = (t * NSEG - first);\n"
"#undef NC\n"
"#undef NSEG\n"
"#define ASSIGN_CF3(a) (float3)(a[0], a[1], a[2])\n"
"	const float3 c0 = ASSIGN_CF3(MarbleTexture_c[first]);\n"
"	const float3 c1 = ASSIGN_CF3(MarbleTexture_c[first + 1]);\n"
"	const float3 c2 = ASSIGN_CF3(MarbleTexture_c[first + 2]);\n"
"	const float3 c3 = ASSIGN_CF3(MarbleTexture_c[first + 3]);\n"
"#undef ASSIGN_CF3\n"
"	// Bezier spline evaluated with de Castilejau's algorithm	\n"
"	float3 s0 = mix(c0, c1, t);\n"
"	float3 s1 = mix(c1, c2, t);\n"
"	float3 s2 = mix(c2, c3, t);\n"
"	s0 = mix(s0, s1, t);\n"
"	s1 = mix(s1, s2, t);\n"
"	// Extra scale of 1.5 to increase variation among colors\n"
"	return 1.5f * mix(s0, s1, t);\n"
"}\n"
"\n"
"float MarbleTexture_ConstEvaluateFloat(__global HitPoint *hitPoint, const float scale,\n"
"		const float omega, const int octaves, const float variation,\n"
"		__global TextureMapping3D *mapping) {\n"
"	return Spectrum_Y(MarbleTexture_Evaluate(hitPoint, scale, omega, octaves,\n"
"			variation, mapping));\n"
"}\n"
"\n"
"float3 MarbleTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint, const float scale,\n"
"		const float omega, const int octaves, const float variation,\n"
"		__global TextureMapping3D *mapping) {\n"
"	return MarbleTexture_Evaluate(hitPoint, scale, omega, octaves,\n"
"			variation, mapping);\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void MarbleTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = MarbleTexture_ConstEvaluateFloat(hitPoint,\n"
"			texture->marble.scale, texture->marble.omega, texture->marble.octaves,\n"
"			texture->marble.variation, &texture->marble.mapping);\n"
"}\n"
"\n"
"void MarbleTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = MarbleTexture_ConstEvaluateSpectrum(hitPoint,\n"
"			texture->marble.scale, texture->marble.omega, texture->marble.octaves,\n"
"			texture->marble.variation, &texture->marble.mapping);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Dots texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_DOTS)\n"
"\n"
"bool DotsTexture_Evaluate(__global HitPoint *hitPoint, __global TextureMapping2D *mapping) {\n"
"	const float2 uv = TextureMapping2D_Map(mapping, hitPoint);\n"
"\n"
"	const int sCell = Floor2Int(uv.s0 + .5f);\n"
"	const int tCell = Floor2Int(uv.s1 + .5f);\n"
"	// Return _insideDot_ result if point is inside dot\n"
"	if (Noise(sCell + .5f, tCell + .5f, .5f) > 0.f) {\n"
"		const float radius = .35f;\n"
"		const float maxShift = 0.5f - radius;\n"
"		const float sCenter = sCell + maxShift *\n"
"			Noise(sCell + 1.5f, tCell + 2.8f, .5f);\n"
"		const float tCenter = tCell + maxShift *\n"
"			Noise(sCell + 4.5f, tCell + 9.8f, .5f);\n"
"		const float ds = uv.s0 - sCenter, dt = uv.s1 - tCenter;\n"
"		if (ds * ds + dt * dt < radius * radius)\n"
"			return true;\n"
"	}\n"
"\n"
"	return false;\n"
"}\n"
"\n"
"float DotsTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const float value1, const float value2, __global TextureMapping2D *mapping) {\n"
"	return DotsTexture_Evaluate(hitPoint, mapping) ? value1 : value2;\n"
"}\n"
"\n"
"float3 DotsTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const float3 value1, const float3 value2, __global TextureMapping2D *mapping) {\n"
"	return DotsTexture_Evaluate(hitPoint, mapping) ? value1 : value2;\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void DotsTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float value1 = texValues[--(*texValuesSize)];\n"
"	const float value2 = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = DotsTexture_ConstEvaluateFloat(hitPoint, value1, value2,\n"
"			&texture->dots.mapping);\n"
"}\n"
"\n"
"void DotsTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float3 value1 = texValues[--(*texValuesSize)];\n"
"	const float3 value2 = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = DotsTexture_ConstEvaluateSpectrum(hitPoint, value1, value2,\n"
"			&texture->dots.mapping);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Brick texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_BRICK)\n"
"\n"
"bool BrickTexture_RunningAlternate(const float3 p, float3 *i, float3 *b,\n"
"		const float run , const float mortarwidth,\n"
"		const float mortarheight, const float mortardepth,\n"
"		int nWhole) {\n"
"	const float sub = nWhole + 0.5f;\n"
"	const float rsub = ceil(sub);\n"
"	(*i).z = floor(p.z);\n"
"	(*b).x = (p.x + (*i).z * run) / sub;\n"
"	(*b).y = (p.y + (*i).z * run) / sub;\n"
"	(*i).x = floor((*b).x);\n"
"	(*i).y = floor((*b).y);\n"
"	(*b).x = ((*b).x - (*i).x) * sub;\n"
"	(*b).y = ((*b).y - (*i).y) * sub;\n"
"	(*b).z = (p.z - (*i).z) * sub;\n"
"	(*i).x += floor((*b).x) / rsub;\n"
"	(*i).y += floor((*b).y) / rsub;\n"
"	(*b).x -= floor((*b).x);\n"
"	(*b).y -= floor((*b).y);\n"
"	return (*b).z > mortarheight && (*b).y > mortardepth &&\n"
"		(*b).x > mortarwidth;\n"
"}\n"
"\n"
"bool BrickTexture_Basket(const float3 p, float3 *i,\n"
"		const float mortarwidth, const float mortardepth,\n"
"		const float proportion, const float invproportion) {\n"
"	(*i).x = floor(p.x);\n"
"	(*i).y = floor(p.y);\n"
"	float bx = p.x - (*i).x;\n"
"	float by = p.y - (*i).y;\n"
"	(*i).x += (*i).y - 2.f * floor(0.5f * (*i).y);\n"
"	const bool split = ((*i).x - 2.f * floor(0.5f * (*i).x)) < 1.f;\n"
"	if (split) {\n"
"		bx = fmod(bx, invproportion);\n"
"		(*i).x = floor(proportion * p.x) * invproportion;\n"
"	} else {\n"
"		by = fmod(by, invproportion);\n"
"		(*i).y = floor(proportion * p.y) * invproportion;\n"
"	}\n"
"	return by > mortardepth && bx > mortarwidth;\n"
"}\n"
"\n"
"bool BrickTexture_Herringbone(const float3 p, float3 *i,\n"
"		const float mortarwidth, const float mortarheight,\n"
"		const float proportion, const float invproportion) {\n"
"	(*i).y = floor(proportion * p.y);\n"
"	const float px = p.x + (*i).y * invproportion;\n"
"	(*i).x = floor(px);\n"
"	float bx = 0.5f * px - floor(px * 0.5f);\n"
"	bx *= 2.f;\n"
"	float by = proportion * p.y - floor(proportion * p.y);\n"
"	by *= invproportion;\n"
"	if (bx > 1.f + invproportion) {\n"
"		bx = proportion * (bx - 1.f);\n"
"		(*i).y -= floor(bx - 1.f);\n"
"		bx -= floor(bx);\n"
"		bx *= invproportion;\n"
"		by = 1.f;\n"
"	} else if (bx > 1.f) {\n"
"		bx = proportion * (bx - 1.f);\n"
"		(*i).y -= floor(bx - 1.f);\n"
"		bx -= floor(bx);\n"
"		bx *= invproportion;\n"
"	}\n"
"	return by > mortarheight && bx > mortarwidth;\n"
"}\n"
"\n"
"bool BrickTexture_Running(const float3 p, float3 *i, float3 *b,\n"
"		const float run , const float mortarwidth,\n"
"		const float mortarheight, const float mortardepth) {\n"
"	(*i).z = floor(p.z);\n"
"	(*b).x = p.x + (*i).z * run;\n"
"	(*b).y = p.y - (*i).z * run;\n"
"	(*i).x = floor((*b).x);\n"
"	(*i).y = floor((*b).y);\n"
"	(*b).z = p.z - (*i).z;\n"
"	(*b).x -= (*i).x;\n"
"	(*b).y -= (*i).y;\n"
"	return (*b).z > mortarheight && (*b).y > mortardepth &&\n"
"		(*b).x > mortarwidth;\n"
"}\n"
"\n"
"bool BrickTexture_English(const float3 p, float3 *i, float3 *b,\n"
"		const float run , const float mortarwidth,\n"
"		const float mortarheight, const float mortardepth) {\n"
"	(*i).z = floor(p.z);\n"
"	(*b).x = p.x + (*i).z * run;\n"
"	(*b).y = p.y - (*i).z * run;\n"
"	(*i).x = floor((*b).x);\n"
"	(*i).y = floor((*b).y);\n"
"	(*b).z = p.z - (*i).z;\n"
"	const float divider = floor(fmod(fabs((*i).z), 2.f)) + 1.f;\n"
"	(*b).x = (divider * (*b).x - floor(divider * (*b).x)) / divider;\n"
"	(*b).y = (divider * (*b).y - floor(divider * (*b).y)) / divider;\n"
"	return (*b).z > mortarheight && (*b).y > mortardepth &&\n"
"		(*b).x > mortarwidth;\n"
"}\n"
"\n"
"bool BrickTexture_Evaluate(__global HitPoint *hitPoint,\n"
"		const MasonryBond bond,\n"
"		const float brickwidth, const float brickheight,\n"
"		const float brickdepth, const float mortarsize,\n"
"		const float3 offset,\n"
"		const float run , const float mortarwidth,\n"
"		const float mortarheight, const float mortardepth,\n"
"		const float proportion, const float invproportion,\n"
"		__global TextureMapping3D *mapping) {\n"
"#define BRICK_EPSILON 1e-3f\n"
"	const float3 P = TextureMapping3D_Map(mapping, hitPoint);\n"
"\n"
"	const float offs = BRICK_EPSILON + mortarsize;\n"
"	float3 bP = P + (float3)(offs, offs, offs);\n"
"\n"
"	// Normalize coordinates according brick dimensions\n"
"	bP.x /= brickwidth;\n"
"	bP.y /= brickdepth;\n"
"	bP.z /= brickheight;\n"
"\n"
"	bP += offset;\n"
"\n"
"	float3 brickIndex;\n"
"	float3 bevel;\n"
"	bool b;\n"
"	switch (bond) {\n"
"		case FLEMISH:\n"
"			b = BrickTexture_RunningAlternate(bP, &brickIndex, &bevel,\n"
"					run , mortarwidth, mortarheight, mortardepth, 1);\n"
"			break;\n"
"		case RUNNING:\n"
"			b = BrickTexture_Running(bP, &brickIndex, &bevel,\n"
"					run, mortarwidth, mortarheight, mortardepth);\n"
"			break;\n"
"		case ENGLISH:\n"
"			b = BrickTexture_English(bP, &brickIndex, &bevel,\n"
"					run, mortarwidth, mortarheight, mortardepth);\n"
"			break;\n"
"		case HERRINGBONE:\n"
"			b = BrickTexture_Herringbone(bP, &brickIndex,\n"
"					mortarwidth, mortarheight, proportion, invproportion);\n"
"			break;\n"
"		case BASKET:\n"
"			b = BrickTexture_Basket(bP, &brickIndex,\n"
"					mortarwidth, mortardepth, proportion, invproportion);\n"
"			break;\n"
"		case KETTING:\n"
"			b = BrickTexture_RunningAlternate(bP, &brickIndex, &bevel,\n"
"					run, mortarwidth, mortarheight, mortardepth, 2);\n"
"			break; \n"
"		default:\n"
"			b = true;\n"
"			break;\n"
"	}\n"
"\n"
"	return b;\n"
"#undef BRICK_EPSILON\n"
"}\n"
"\n"
"float BrickTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const float value1, const float value2, const float value3,\n"
"		const MasonryBond bond,\n"
"		const float brickwidth, const float brickheight,\n"
"		const float brickdepth, const float mortarsize,\n"
"		const float3 offset,\n"
"		const float run , const float mortarwidth,\n"
"		const float mortarheight, const float mortardepth,\n"
"		const float proportion, const float invproportion,\n"
"		__global TextureMapping3D *mapping) {\n"
"	return BrickTexture_Evaluate(hitPoint,\n"
"			bond,\n"
"			brickwidth, brickheight,\n"
"			brickdepth, mortarsize,\n"
"			offset,\n"
"			run , mortarwidth,\n"
"			mortarheight, mortardepth,\n"
"			proportion, invproportion,\n"
"			mapping) ? (value1 * value3) : value2;\n"
"}\n"
"\n"
"float3 BrickTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const float3 value1, const float3 value2, const float3 value3,\n"
"		const MasonryBond bond,\n"
"		const float brickwidth, const float brickheight,\n"
"		const float brickdepth, const float mortarsize,\n"
"		const float3 offset,\n"
"		const float run , const float mortarwidth,\n"
"		const float mortarheight, const float mortardepth,\n"
"		const float proportion, const float invproportion,\n"
"		__global TextureMapping3D *mapping) {\n"
"	return BrickTexture_Evaluate(hitPoint,\n"
"			bond,\n"
"			brickwidth, brickheight,\n"
"			brickdepth, mortarsize,\n"
"			offset,\n"
"			run , mortarwidth,\n"
"			mortarheight, mortardepth,\n"
"			proportion, invproportion,\n"
"			mapping) ? (value1 * value3) : value2;\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void BrickTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float value1 = texValues[--(*texValuesSize)];\n"
"	const float value2 = texValues[--(*texValuesSize)];\n"
"	const float value3 = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = BrickTexture_ConstEvaluateFloat(hitPoint,\n"
"			value1, value2, value3,\n"
"			texture->brick.bond,\n"
"			texture->brick.brickwidth, texture->brick.brickheight,\n"
"			texture->brick.brickdepth, texture->brick.mortarsize,\n"
"			VLOAD3F(&texture->brick.offsetx),\n"
"			texture->brick.run , texture->brick.mortarwidth,\n"
"			texture->brick.mortarheight, texture->brick.mortardepth,\n"
"			texture->brick.proportion, texture->brick.invproportion,\n"
"			&texture->brick.mapping);\n"
"}\n"
"\n"
"void BrickTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float3 value1 = texValues[--(*texValuesSize)];\n"
"	const float3 value2 = texValues[--(*texValuesSize)];\n"
"	const float3 value3 = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = BrickTexture_ConstEvaluateSpectrum(hitPoint,\n"
"			value1, value2, value3,\n"
"			texture->brick.bond,\n"
"			texture->brick.brickwidth, texture->brick.brickheight,\n"
"			texture->brick.brickdepth, texture->brick.mortarsize,\n"
"			VLOAD3F(&texture->brick.offsetx),\n"
"			texture->brick.run , texture->brick.mortarwidth,\n"
"			texture->brick.mortarheight, texture->brick.mortardepth,\n"
"			texture->brick.proportion, texture->brick.invproportion,\n"
"			&texture->brick.mapping);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Add texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_TEX_ADD)\n"
"\n"
"float AddTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const float value1, const float value2) {\n"
"	return value1 + value2;\n"
"}\n"
"\n"
"float3 AddTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const float3 value1, const float3 value2) {\n"
"	return value1 + value2;\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void AddTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float value1 = texValues[--(*texValuesSize)];\n"
"	const float value2 = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = AddTexture_ConstEvaluateFloat(hitPoint, value1, value2);\n"
"}\n"
"\n"
"void AddTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float3 value1 = texValues[--(*texValuesSize)];\n"
"	const float3 value2 = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = AddTexture_ConstEvaluateSpectrum(hitPoint, value1, value2);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Subtract texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_TEX_SUBTRACT)\n"
"\n"
"float SubtractTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"const float value1, const float value2) {\n"
"	return value1 - value2;\n"
"}\n"
"\n"
"float3 SubtractTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"const float3 value1, const float3 value2) {\n"
"	return value1 - value2;\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void SubtractTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float value1 = texValues[--(*texValuesSize)];\n"
"	const float value2 = texValues[--(*texValuesSize)];\n"
"	\n"
"	texValues[(*texValuesSize)++] = SubtractTexture_ConstEvaluateFloat(hitPoint, value1, value2);\n"
"}\n"
"\n"
"void SubtractTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float3 value1 = texValues[--(*texValuesSize)];\n"
"	const float3 value2 = texValues[--(*texValuesSize)];\n"
"	\n"
"	texValues[(*texValuesSize)++] = SubtractTexture_ConstEvaluateSpectrum(hitPoint, value1, value2);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Windy texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_WINDY)\n"
"\n"
"float WindyTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		__global TextureMapping3D *mapping) {\n"
"	const float3 mapP = TextureMapping3D_Map(mapping, hitPoint);\n"
"\n"
"	const float windStrength = FBm(.1f * mapP, .5f, 3);\n"
"	const float waveHeight = FBm(mapP, .5f, 6);\n"
"\n"
"	return fabs(windStrength) * waveHeight;\n"
"}\n"
"\n"
"float3 WindyTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		__global TextureMapping3D *mapping) {\n"
"	return WindyTexture_ConstEvaluateFloat(hitPoint, mapping);\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void WindyTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = WindyTexture_ConstEvaluateFloat(hitPoint,\n"
"			&texture->windy.mapping);\n"
"}\n"
"\n"
"void WindyTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = WindyTexture_ConstEvaluateSpectrum(hitPoint,\n"
"			&texture->windy.mapping);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Wrinkled texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_WRINKLED)\n"
"\n"
"float WrinkledTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const float omega, const int octaves,\n"
"		__global TextureMapping3D *mapping) {\n"
"	const float3 mapP = TextureMapping3D_Map(mapping, hitPoint);\n"
"\n"
"	return Turbulence(mapP, omega, octaves);\n"
"}\n"
"\n"
"float3 WrinkledTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const float omega, const int octaves,\n"
"		__global TextureMapping3D *mapping) {\n"
"	return WrinkledTexture_ConstEvaluateFloat(hitPoint, omega, octaves, mapping);\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void WrinkledTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = WrinkledTexture_ConstEvaluateFloat(hitPoint,\n"
"			texture->wrinkled.omega, texture->wrinkled.octaves,\n"
"			&texture->wrinkled.mapping);\n"
"}\n"
"\n"
"void WrinkledTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = WrinkledTexture_ConstEvaluateSpectrum(hitPoint,\n"
"			texture->wrinkled.omega, texture->wrinkled.octaves,\n"
"			&texture->wrinkled.mapping);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// UV texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_TEX_UV)\n"
"\n"
"float UVTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		__global TextureMapping2D *mapping) {\n"
"	const float2 uv = TextureMapping2D_Map(mapping, hitPoint);\n"
"\n"
"	return Spectrum_Y((float3)(uv.s0 - Floor2Int(uv.s0), uv.s1 - Floor2Int(uv.s1), 0.f));\n"
"}\n"
"\n"
"float3 UVTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		__global TextureMapping2D *mapping) {\n"
"	const float2 uv = TextureMapping2D_Map(mapping, hitPoint);\n"
"\n"
"	return (float3)(uv.s0 - Floor2Int(uv.s0), uv.s1 - Floor2Int(uv.s1), 0.f);\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void UVTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = UVTexture_ConstEvaluateFloat(hitPoint,\n"
"			&texture->uvTex.mapping);\n"
"}\n"
"\n"
"void UVTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = UVTexture_ConstEvaluateSpectrum(hitPoint,\n"
"			&texture->uvTex.mapping);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Band texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_TEX_BAND)\n"
"\n"
"float BandTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const uint size, __global float *offsets,\n"
"		__global Spectrum *values, const float amt) {\n"
"	const float a = clamp(amt, 0.f, 1.f);\n"
"\n"
"	const uint last = size - 1;\n"
"	if (a < offsets[0])\n"
"		return Spectrum_Y(VLOAD3F(values[0].c));\n"
"	else if (a >= offsets[last])\n"
"		return Spectrum_Y(VLOAD3F(values[last].c));\n"
"	else {\n"
"		uint p = 0;\n"
"		for (; p <= last; ++p) {\n"
"			if (a < offsets[p])\n"
"				break;\n"
"		}\n"
"\n"
"		const float p1 = Spectrum_Y(VLOAD3F(values[p - 1].c));\n"
"		const float p0 = Spectrum_Y(VLOAD3F(values[p].c));\n"
"		const float o1 = offsets[p - 1];\n"
"		const float o0 = offsets[p];\n"
"		return Lerp((a - o1) / (o0 - o1), p1, p0);\n"
"	}\n"
"}\n"
"\n"
"float3 BandTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const uint size, __global float *offsets,\n"
"		__global Spectrum *values, const float3 amt) {\n"
"	const float a = clamp(Spectrum_Y(amt), 0.f, 1.f);\n"
"\n"
"	const uint last = size - 1;\n"
"	if (a < offsets[0])\n"
"		return VLOAD3F(values[0].c);\n"
"	else if (a >= offsets[last])\n"
"		return VLOAD3F(values[last].c);\n"
"	else {\n"
"		uint p = 0;\n"
"		for (; p <= last; ++p) {\n"
"			if (a < offsets[p])\n"
"				break;\n"
"		}\n"
"\n"
"		const float3 p1 = VLOAD3F(values[p - 1].c);\n"
"		const float3 p0 = VLOAD3F(values[p].c);\n"
"		const float o1 = offsets[p - 1];\n"
"		const float o0 = offsets[p];\n"
"		return Lerp3((a - o1) / (o0 - o1), p1, p0);\n"
"	}\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void BandTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float a = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = BandTexture_ConstEvaluateFloat(hitPoint, texture->band.size,\n"
"			texture->band.offsets, texture->band.values, a);\n"
"}\n"
"\n"
"void BandTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	const float3 a = texValues[--(*texValuesSize)];\n"
"\n"
"	texValues[(*texValuesSize)++] = BandTexture_ConstEvaluateSpectrum(hitPoint, texture->band.size,\n"
"			texture->band.offsets, texture->band.values, a);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// HitPointColor texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_TEX_HITPOINTCOLOR)\n"
"\n"
"float HitPointColorTexture_ConstEvaluateFloat(__global HitPoint *hitPoint) {\n"
"	return Spectrum_Y(VLOAD3F(hitPoint->color.c));\n"
"}\n"
"\n"
"float3 HitPointColorTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint) {\n"
"	return VLOAD3F(hitPoint->color.c);\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void HitPointColorTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = HitPointColorTexture_ConstEvaluateFloat(hitPoint);\n"
"}\n"
"\n"
"void HitPointColorTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = HitPointColorTexture_ConstEvaluateSpectrum(hitPoint);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// HitPointAlpha texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_TEX_HITPOINTALPHA)\n"
"\n"
"float HitPointAlphaTexture_ConstEvaluateFloat(__global HitPoint *hitPoint) {\n"
"	return hitPoint->alpha;\n"
"}\n"
"\n"
"float3 HitPointAlphaTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint) {\n"
"	const float alpha = hitPoint->alpha;\n"
"	return (float3)(alpha, alpha, alpha);\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void HitPointAlphaTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = HitPointAlphaTexture_ConstEvaluateFloat(hitPoint);\n"
"}\n"
"\n"
"void HitPointAlphaTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = HitPointAlphaTexture_ConstEvaluateSpectrum(hitPoint);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// HitPointGrey texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_TEX_HITPOINTGREY)\n"
"\n"
"float HitPointGreyTexture_ConstEvaluateFloat(__global HitPoint *hitPoint, const uint channel) {\n"
"	switch (channel) {\n"
"		case 0:\n"
"			return hitPoint->color.c[0];\n"
"		case 1:\n"
"			return hitPoint->color.c[1];\n"
"		case 2:\n"
"			return hitPoint->color.c[2];\n"
"		default:\n"
"			return Spectrum_Y(VLOAD3F(hitPoint->color.c));\n"
"	}\n"
"}\n"
"\n"
"float3 HitPointGreyTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint, const uint channel) {\n"
"	float v;\n"
"	switch (channel) {\n"
"		case 0:\n"
"			v = hitPoint->color.c[0];\n"
"			break;\n"
"		case 1:\n"
"			v = hitPoint->color.c[1];\n"
"			break;\n"
"		case 2:\n"
"			v = hitPoint->color.c[2];\n"
"			break;\n"
"		default:\n"
"			v = Spectrum_Y(VLOAD3F(hitPoint->color.c));\n"
"			break;\n"
"	}\n"
"\n"
"	return (float3)(v, v, v);\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void HitPointGreyTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = HitPointGreyTexture_ConstEvaluateFloat(hitPoint,\n"
"			texture->hitPointGrey.channel);\n"
"}\n"
"\n"
"void HitPointGreyTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = HitPointGreyTexture_ConstEvaluateSpectrum(hitPoint,\n"
"			texture->hitPointGrey.channel);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// NormalMap texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_TEX_NORMALMAP)\n"
"\n"
"float NormalMapTexture_ConstEvaluateFloat(__global HitPoint *hitPoint) {\n"
"    return 0.f;\n"
"}\n"
"\n"
"float3 NormalMapTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint) {\n"
"	return (float3)(0.f, 0.f, 0.f);\n"
"}\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"void NormalMapTexture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"    texValues[(*texValuesSize)++] = NormalMapTexture_ConstEvaluateFloat(hitPoint);\n"
"}\n"
"\n"
"void NormalMapTexture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize) {\n"
"	texValues[(*texValuesSize)++] = NormalMapTexture_ConstEvaluateSpectrum(hitPoint);\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Generic texture functions with support for recursive textures\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"\n"
"uint Texture_AddSubTexture(__global Texture *texture,\n"
"		__global Texture *todoTex[TEXTURE_STACK_SIZE], uint *todoTexSize\n"
"		TEXTURES_PARAM_DECL) {\n"
"	switch (texture->type) {\n"
"#if defined(PARAM_ENABLE_TEX_SCALE)\n"
"		case SCALE_TEX:\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->scaleTex.tex1Index];\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->scaleTex.tex2Index];\n"
"			return 2;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_FRESNEL_APPROX_N)\n"
"		case FRESNEL_APPROX_N:\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->fresnelApproxN.texIndex];\n"
"			return 1;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_FRESNEL_APPROX_K)\n"
"		case FRESNEL_APPROX_K:\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->fresnelApproxK.texIndex];\n"
"			return 1;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_CHECKERBOARD2D)\n"
"		case CHECKERBOARD2D:\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->checkerBoard2D.tex1Index];\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->checkerBoard2D.tex2Index];\n"
"			return 2;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_CHECKERBOARD3D)\n"
"		case CHECKERBOARD3D:\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->checkerBoard3D.tex1Index];\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->checkerBoard3D.tex2Index];\n"
"			return 2;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_MIX)\n"
"		case MIX_TEX:\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->mixTex.amountTexIndex];\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->mixTex.tex1Index];\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->mixTex.tex2Index];\n"
"			return 3;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_DOTS)\n"
"		case DOTS:\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->dots.insideIndex];\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->dots.outsideIndex];\n"
"			return 2;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BRICK)\n"
"		case BRICK:\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->brick.tex1Index];\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->brick.tex2Index];\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->brick.tex3Index];\n"
"			return 3;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_ADD)\n"
"		case ADD_TEX:\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->addTex.tex1Index];\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->addTex.tex2Index];\n"
"			return 2;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_SUBTRACT)\n"
"		case SUBTRACT_TEX:\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->subtractTex.tex1Index];\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->subtractTex.tex2Index];\n"
"			return 2;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_BAND)\n"
"		case BAND_TEX:\n"
"			todoTex[(*todoTexSize)++] = &texs[texture->band.amountTexIndex];\n"
"			return 1;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_NORMALMAP)\n"
"		case NORMALMAP_TEX:\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_HITPOINTGREY)\n"
"		case HITPOINTGREY:\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_HITPOINTALPHA)\n"
"		case HITPOINTALPHA:\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_HITPOINTCOLOR)\n"
"		case HITPOINTCOLOR:\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_UV)\n"
"		case UV_TEX:\n"
"#endif\n"
"#if defined(PARAM_ENABLE_WRINKLED)\n"
"		case WRINKLED:\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_WOOD)\n"
"		case BLENDER_WOOD:\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_CLOUDS)\n"
"		case BLENDER_CLOUDS:\n"
"#endif\n"
"#if defined(PARAM_ENABLE_WINDY)\n"
"		case WINDY:\n"
"#endif\n"
"#if defined(PARAM_ENABLE_MARBLE)\n"
"		case MARBLE:\n"
"#endif\n"
"#if defined(PARAM_ENABLE_FBM_TEX)\n"
"		case FBM_TEX:\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_CONST_FLOAT)\n"
"		case CONST_FLOAT:\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_CONST_FLOAT3)\n"
"		case CONST_FLOAT3:\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_IMAGEMAP)\n"
"		case IMAGEMAP:\n"
"#endif\n"
"		default:\n"
"			return 0;\n"
"	}\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Float texture channel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"\n"
"void Texture_EvaluateFloat(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float texValues[TEXTURE_STACK_SIZE], uint *texValuesSize\n"
"		IMAGEMAPS_PARAM_DECL) {\n"
"	switch (texture->type) {\n"
"#if defined(PARAM_ENABLE_TEX_CONST_FLOAT)\n"
"		case CONST_FLOAT:\n"
"			ConstFloatTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_CONST_FLOAT3)\n"
"		case CONST_FLOAT3:\n"
"			ConstFloat3Texture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_IMAGEMAP)\n"
"		case IMAGEMAP:\n"
"			ImageMapTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize\n"
"					IMAGEMAPS_PARAM);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_SCALE)\n"
"		case SCALE_TEX:\n"
"			ScaleTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_FRESNEL_APPROX_N)\n"
"		case FRESNEL_APPROX_N:\n"
"			FresnelApproxNTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_FRESNEL_APPROX_K)\n"
"		case FRESNEL_APPROX_K:\n"
"			FresnelApproxKTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_CHECKERBOARD2D)\n"
"		case CHECKERBOARD2D:\n"
"			CheckerBoard2DTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_CHECKERBOARD3D)\n"
"		case CHECKERBOARD3D:\n"
"			CheckerBoard3DTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_MIX)\n"
"		case MIX_TEX:\n"
"			MixTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_FBM_TEX)\n"
"		case FBM_TEX:\n"
"			FBMTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_MARBLE)\n"
"		case MARBLE:\n"
"			MarbleTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_DOTS)\n"
"		case DOTS:\n"
"			DotsTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BRICK)\n"
"		case BRICK:\n"
"			BrickTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_ADD)\n"
"		case ADD_TEX:\n"
"			AddTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_SUBTRACT)\n"
"		case SUBTRACT_TEX:\n"
"			SubtractTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"			#endif\n"
"#if defined(PARAM_ENABLE_WINDY)\n"
"		case WINDY:\n"
"			WindyTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_BLEND)\n"
"		case BLENDER_BLEND:\n"
"			BlenderBlendTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"+#endif#if defined(PARAM_ENABLE_BLENDER_CLOUDS)\n"
"		case BLENDER_CLOUDS:\n"
"			BlenderCloudsTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_DISTORTED_NOISE)\n"
"		case BLENDER_DISTORTED_NOISE:		    \n"
"			BlenderDistortedNoiseTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_MAGIC)\n"
"		case BLENDER_MAGIC:\n"
"			BlenderMagicTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_MARBLE)\n"
"		case BLENDER_MARBLE:\n"
"			BlenderMarbleTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_STUCCI)\n"
"		case BLENDER_STUCCI:\n"
"			BlenderStucciTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_WOOD)\n"
"		case BLENDER_WOOD:\n"
"			BlenderWoodTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_VORONOI)\n"
"		case BLENDER_VORONOID:\n"
"			BlenderVoronoiTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_WRINKLED)\n"
"		case WRINKLED:\n"
"			WrinkledTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_UV)\n"
"		case UV_TEX:\n"
"			UVTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_BAND)\n"
"		case BAND_TEX:\n"
"			BandTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_HITPOINTCOLOR)\n"
"		case HITPOINTCOLOR:\n"
"			HitPointColorTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_HITPOINTALPHA)\n"
"		case HITPOINTALPHA:\n"
"			HitPointAlphaTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_HITPOINTGREY)\n"
"		case HITPOINTGREY:\n"
"			HitPointGreyTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_NORMALMAP)\n"
"		case NORMALMAP_TEX:\n"
"			NormalMapTexture_EvaluateFloat(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"		default:\n"
"			// Do nothing\n"
"			break;\n"
"	}\n"
"}\n"
"\n"
"float Texture_GetFloatValue(const uint texIndex, __global HitPoint *hitPoint\n"
"		TEXTURES_PARAM_DECL) {\n"
"	__global Texture *texture = &texs[texIndex];\n"
"	__global Texture *todoTex[TEXTURE_STACK_SIZE];\n"
"	uint todoTexSize = 0;\n"
"\n"
"	__global Texture *pendingTex[TEXTURE_STACK_SIZE];\n"
"	uint targetTexCount[TEXTURE_STACK_SIZE];\n"
"	uint pendingTexSize = 0;\n"
"\n"
"	float texValues[TEXTURE_STACK_SIZE];\n"
"	uint texValuesSize = 0;\n"
"\n"
"	const uint subTexCount = Texture_AddSubTexture(texture, todoTex, &todoTexSize\n"
"			TEXTURES_PARAM);\n"
"	if (subTexCount == 0) {\n"
"		// A fast path for evaluating non recursive textures\n"
"		Texture_EvaluateFloat(texture, hitPoint, texValues, &texValuesSize\n"
"			IMAGEMAPS_PARAM);\n"
"	} else {\n"
"		// Normal complex path for evaluating non recursive textures\n"
"		pendingTex[pendingTexSize] = texture;\n"
"		targetTexCount[pendingTexSize++] = subTexCount;\n"
"		do {\n"
"			if ((pendingTexSize > 0) && (texValuesSize == targetTexCount[pendingTexSize - 1])) {\n"
"				// Pop the a texture to do\n"
"				__global Texture *tex = pendingTex[--pendingTexSize];\n"
"\n"
"				Texture_EvaluateFloat(tex, hitPoint, texValues, &texValuesSize\n"
"						IMAGEMAPS_PARAM);\n"
"				continue;\n"
"			}\n"
"\n"
"			if (todoTexSize > 0) {\n"
"				// Pop the a texture to do\n"
"				__global Texture *tex = todoTex[--todoTexSize];\n"
"\n"
"				// Add this texture to the list of pending one\n"
"				const uint subTexCount = Texture_AddSubTexture(tex, todoTex, &todoTexSize\n"
"						TEXTURES_PARAM);\n"
"				pendingTex[pendingTexSize] = tex;\n"
"				targetTexCount[pendingTexSize++] = subTexCount + texValuesSize;\n"
"			}\n"
"		} while ((todoTexSize > 0) || (pendingTexSize > 0));\n"
"	}\n"
"\n"
"	return texValues[0];\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Color texture channel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_DISABLE_TEX_DYNAMIC_EVALUATION)\n"
"\n"
"void Texture_EvaluateSpectrum(__global Texture *texture, __global HitPoint *hitPoint,\n"
"		float3 texValues[TEXTURE_STACK_SIZE], uint *texValuesSize\n"
"		IMAGEMAPS_PARAM_DECL) {\n"
"	switch (texture->type) {\n"
"#if defined(PARAM_ENABLE_TEX_CONST_FLOAT)\n"
"		case CONST_FLOAT:\n"
"			ConstFloatTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_CONST_FLOAT3)\n"
"		case CONST_FLOAT3:\n"
"			ConstFloat3Texture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_IMAGEMAP)\n"
"		case IMAGEMAP:\n"
"			ImageMapTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize\n"
"					IMAGEMAPS_PARAM);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_SCALE)\n"
"		case SCALE_TEX:\n"
"			ScaleTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_FRESNEL_APPROX_N)\n"
"		case FRESNEL_APPROX_N:\n"
"			FresnelApproxNTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_FRESNEL_APPROX_K)\n"
"		case FRESNEL_APPROX_K:\n"
"			FresnelApproxKTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_CHECKERBOARD2D)\n"
"		case CHECKERBOARD2D:\n"
"			CheckerBoard2DTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_CHECKERBOARD3D)\n"
"		case CHECKERBOARD3D:\n"
"			CheckerBoard3DTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_MIX)\n"
"		case MIX_TEX:\n"
"			MixTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_FBM_TEX)\n"
"		case FBM_TEX:\n"
"			FBMTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_MARBLE)\n"
"		case MARBLE:\n"
"			MarbleTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_DOTS)\n"
"		case DOTS:\n"
"			DotsTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BRICK)\n"
"		case BRICK:\n"
"			BrickTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_ADD)\n"
"		case ADD_TEX:\n"
"			AddTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_SUBTRACT)\n"
"		case SUBTRACT_TEX:\n"
"			SubtractTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_WINDY)\n"
"		case WINDY:\n"
"			WindyTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_BLEND)\n"
"		case BLENDER_BLEND:\n"
"			BlenderBlendTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_CLOUDS)\n"
"		case BLENDER_CLOUDS:\n"
"			BlenderCloudsTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_DISTORTED_NOISE)\n"
"		case BLENDER_DISTORTED_NOISE:\n"
"			BlenderDistortedNoiseTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_MAGIC)\n"
"		case BLENDER_MAGIC:\n"
"			BlenderMagicTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_MARBLE)\n"
"		case BLENDER_MARBLE:\n"
"			BlenderMarbleTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_STUCCI)\n"
"		case BLENDER_STUCCI:\n"
"			BlenderStucciTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_WOOD)\n"
"		case BLENDER_WOOD:\n"
"			BlenderWoodTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_BLENDER_VORONOI)\n"
"		case BLENDER_VORONOI:\n"
"			BlenderVoronoiTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_WRINKLED)\n"
"		case WRINKLED:\n"
"			WrinkledTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_UV)\n"
"		case UV_TEX:\n"
"			UVTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_BAND)\n"
"		case BAND_TEX:\n"
"			BandTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_HITPOINTCOLOR)\n"
"		case HITPOINTCOLOR:\n"
"			HitPointColorTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_HITPOINTALPHA)\n"
"		case HITPOINTALPHA:\n"
"			HitPointAlphaTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_HITPOINTGREY)\n"
"		case HITPOINTGREY:\n"
"			HitPointGreyTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"#if defined(PARAM_ENABLE_TEX_NORMALMAP)\n"
"		case NORMALMAP_TEX:\n"
"			NormalMapTexture_EvaluateSpectrum(texture, hitPoint, texValues, texValuesSize);\n"
"			break;\n"
"#endif\n"
"		default:\n"
"			// Do nothing\n"
"			break;\n"
"	}\n"
"}\n"
"\n"
"float3 Texture_GetSpectrumValue(const uint texIndex, __global HitPoint *hitPoint\n"
"		TEXTURES_PARAM_DECL) {\n"
"	__global Texture *texture = &texs[texIndex];\n"
"\n"
"	__global Texture *todoTex[TEXTURE_STACK_SIZE];\n"
"	uint todoTexSize = 0;\n"
"\n"
"	__global Texture *pendingTex[TEXTURE_STACK_SIZE];\n"
"	uint targetTexCount[TEXTURE_STACK_SIZE];\n"
"	uint pendingTexSize = 0;\n"
"\n"
"	float3 texValues[TEXTURE_STACK_SIZE];\n"
"	uint texValuesSize = 0;\n"
"\n"
"	const uint subTexCount = Texture_AddSubTexture(texture, todoTex, &todoTexSize\n"
"			TEXTURES_PARAM);\n"
"	if (subTexCount == 0) {\n"
"		// A fast path for evaluating non recursive textures\n"
"		Texture_EvaluateSpectrum(texture, hitPoint, texValues, &texValuesSize\n"
"			IMAGEMAPS_PARAM);\n"
"	} else {\n"
"		// Normal complex path for evaluating non recursive textures\n"
"		pendingTex[pendingTexSize] = texture;\n"
"		targetTexCount[pendingTexSize++] = subTexCount;\n"
"		do {\n"
"			if ((pendingTexSize > 0) && (texValuesSize == targetTexCount[pendingTexSize - 1])) {\n"
"				// Pop the a texture to do\n"
"				__global Texture *tex = pendingTex[--pendingTexSize];\n"
"\n"
"				Texture_EvaluateSpectrum(tex, hitPoint, texValues, &texValuesSize\n"
"						IMAGEMAPS_PARAM);\n"
"				continue;\n"
"			}\n"
"\n"
"			if (todoTexSize > 0) {\n"
"				// Pop the a texture to do\n"
"				__global Texture *tex = todoTex[--todoTexSize];\n"
"\n"
"				// Add this texture to the list of pending one\n"
"				const uint subTexCount = Texture_AddSubTexture(tex, todoTex, &todoTexSize\n"
"						TEXTURES_PARAM);\n"
"				pendingTex[pendingTexSize] = tex;\n"
"				targetTexCount[pendingTexSize++] = subTexCount + texValuesSize;\n"
"			}\n"
"		} while ((todoTexSize > 0) || (pendingTexSize > 0));\n"
"	}\n"
"\n"
"	return texValues[0];\n"
"}\n"
"\n"
"#endif\n"
; } }
