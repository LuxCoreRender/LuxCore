#include <string>
namespace slg { namespace ocl {
std::string KernelSource_texture_hsv_funcs = 
"#line 2 \"texture_hsv_funcs.cl\"\n"
"\n"
"/***************************************************************************\n"
" * Copyright 1998-2018 by authors (see AUTHORS.txt)                        *\n"
" *                                                                         *\n"
" *   This file is part of LuxCoreRender.                                   *\n"
" *                                                                         *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");         *\n"
" * you may not use this file except in compliance with the License.        *\n"
" * You may obtain a copy of the License at                                 *\n"
" *                                                                         *\n"
" *     http://www.apache.org/licenses/LICENSE-2.0                          *\n"
" *                                                                         *\n"
" * Unless required by applicable law or agreed to in writing, software     *\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,       *\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*\n"
" * See the License for the specific language governing permissions and     *\n"
" * limitations under the License.                                          *\n"
" ***************************************************************************/\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Hsv texture\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_ENABLE_TEX_HSV)\n"
"\n"
"/*\n"
" * Copyright 2011-2013 Blender Foundation\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" * http://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"OPENCL_FORCE_INLINE float3 HsvTexture_RgbToHsv(const float3 rgb) {\n"
"	float cmax, cmin, h, s, v, cdelta;\n"
"\n"
"	cmax = fmax(rgb.s0, fmax(rgb.s1, rgb.s2));\n"
"	cmin = fmin(rgb.s0, fmin(rgb.s1, rgb.s2));\n"
"	cdelta = cmax - cmin;\n"
"\n"
"	v = cmax;\n"
"\n"
"	if (cmax != 0.f)\n"
"		s = cdelta / cmax;\n"
"	else {\n"
"		s = 0.f;\n"
"		h = 0.f;\n"
"	}\n"
"\n"
"	if (s != 0.0f) {\n"
"		float3 c;\n"
"		float icdelta = 1.f / cdelta;\n"
"		c.s0 = (cmax - rgb.s0) * icdelta;\n"
"		c.s1 = (cmax - rgb.s1) * icdelta;\n"
"		c.s2 = (cmax - rgb.s2) * icdelta;\n"
"\n"
"		if (rgb.s0 == cmax)\n"
"			h = c.s2 - c.s1;\n"
"		else if (rgb.s1 == cmax)\n"
"			h = 2.f + c.s0 - c.s2;\n"
"		else\n"
"			h = 4.f + c.s1 - c.s0;\n"
"\n"
"		h /= 6.f;\n"
"\n"
"		if (h < 0.f)\n"
"			h += 1.f;\n"
"	} else\n"
"		h = 0.f;\n"
"\n"
"	return (float3)(h, s, v);\n"
"}\n"
"\n"
"OPENCL_FORCE_INLINE float3 HsvTexture_HsvToRgb(const float3 hsv) {\n"
"	float i, f, p, q, t, h, s, v;\n"
"\n"
"	h = hsv.s0;\n"
"	s = hsv.s1;\n"
"	v = hsv.s2;\n"
"\n"
"	if (s != 0.f) {\n"
"		if (h == 1.f)\n"
"			h = 0.f;\n"
"\n"
"		h *= 6.f;\n"
"		i = Floor2Int(h);\n"
"		f = h - i;\n"
"\n"
"		p = v * (1.f - s);\n"
"		q = v * (1.f - (s * f));\n"
"		t = v * (1.f - (s * (1.f - f)));\n"
"\n"
"		if (i == 0.f) return (float3)(v, t, p);\n"
"		else if (i == 1.f) return (float3)(q, v, p);\n"
"		else if (i == 2.f) return (float3)(p, v, t);\n"
"		else if (i == 3.f) return (float3)(p, q, v);\n"
"		else if (i == 4.f) return (float3)(t, p, v);\n"
"		else return (float3)(v, p, q);\n"
"	} else\n"
"		return (float3)(v, v, v);\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"OPENCL_FORCE_INLINE float3 HsvTexture_ApplyTransformation(const float3 colorHitpoint,\n"
"		const float hueHitpoint, const float satHitpoint,\n"
"		const float valHitpoint) {\n"
"\n"
"	const float3 input = Spectrum_Clamp(colorHitpoint);\n"
"	\n"
"	// colorHitpoint to HSV\n"
"	float3 hsv = HsvTexture_RgbToHsv(input);\n"
"\n"
"	// Manipulate HSV\n"
"	hsv.s0 += hueHitpoint + .5f;\n"
"	hsv.s0 = fmod(hsv.s0, 1.f);\n"
"	hsv.s1 *= satHitpoint;\n"
"	hsv.s2 *= valHitpoint;\n"
"\n"
"	// Clamp color to prevent negative values caused by over-saturation\n"
"	return Spectrum_Clamp(HsvTexture_HsvToRgb(hsv));\n"
"}\n"
"\n"
"OPENCL_FORCE_NOT_INLINE float HsvTexture_ConstEvaluateFloat(__global HitPoint *hitPoint,\n"
"		const float3 colorHitpoint,\n"
"		const float hueHitpoint, const float satHitpoint,\n"
"		const float valHitpoint) {\n"
"	return Spectrum_Y(HsvTexture_ApplyTransformation(colorHitpoint, hueHitpoint, satHitpoint, valHitpoint));\n"
"}\n"
"\n"
"OPENCL_FORCE_NOT_INLINE float3 HsvTexture_ConstEvaluateSpectrum(__global HitPoint *hitPoint,\n"
"		const float3 colorHitpoint,\n"
"		const float hueHitpoint, const float satHitpoint,\n"
"		const float valHitpoint) {\n"
"	return HsvTexture_ApplyTransformation(colorHitpoint, hueHitpoint, satHitpoint, valHitpoint);\n"
"}\n"
"\n"
"#endif\n"
; } }
